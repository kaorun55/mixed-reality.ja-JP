---
title: MR 共有 250-HoloLens とイマーシブヘッドセット
description: Unity、Visual Studio、HoloLens、および Windows Mixed Reality ヘッドセットを使用したこのコーディングチュートリアルに従って、mixed reality デバイス間でのホログラムの共有の詳細を確認してください。
author: keveleigh
ms.author: kurtie
ms.date: 03/21/2018
ms.topic: article
keywords: holotoolkit、mixedrealitytoolkit、mixedrealitytoolkit、イマーシブ、motion controller、共有、xbox コントローラー、ネットワーク、クロスデバイス
ms.openlocfilehash: 9e1cb0d168b8bf830b4477190516cd19caef7972
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/24/2019
ms.locfileid: "63506116"
---
>[!NOTE]
>Mixed Reality Academy チュートリアルは、HoloLens (第1世代) と Mixed Reality イマーシブヘッドセットを念頭に置いて設計されています。  そのため、これらのデバイスの開発に関するガイダンスをまだ探している開発者には、これらのチュートリアルを残しておくことが重要です。  これらのチュートリアルは **_いない_** 最新のツールセットや相互作用が使用されている HoloLens 2 で更新されます。  サポートされているデバイスでの作業を続行するために管理されます。 今後、HoloLens 2 向けの開発方法を示す新しい一連のチュートリアルが掲載されています。  この通知は、これらのチュートリアルが投稿されたときのリンクと共に更新されます。

<br>

# <a name="mr-sharing-250-hololens-and-immersive-headsets"></a>MR 共有 250:HoloLens とイマーシブヘッドセット

ユニバーサル Windows プラットフォーム (UWP) の柔軟性により、複数のデバイスにまたがるアプリケーションを簡単に作成できます。 この柔軟性により、各デバイスの強みを活用するエクスペリエンスを作成できます。 このチュートリアルでは、HoloLens と Windows Mixed Reality の両方のイマーシブヘッドセットで実行される基本的な共有エクスペリエンスについて説明します。 このコンテンツはもともと、ワシントン州シアトルの Microsoft Build 2017 カンファレンスで配信されました。

**このチュートリアルでは、次のことについて説明します。**

* UNET を使用してネットワークをセットアップします。
* 混合の現実のデバイス間でホログラムを共有します。
* 使用されている mixed reality デバイスに応じて、アプリケーションの別のビューを確立します。
* HoloLens ユーザーが、いくつかの単純なパズルを通じてユーザーをイマーシブヘッドセットに導く共有エクスペリエンスを作成します。

## <a name="device-support"></a>デバイスのサポート

<table>
<tr>
<th>まで</th><th style="width:150px"> <a href="hololens-hardware-details.md">HoloLens</a></th><th style="width:150px"> <a href="immersive-headset-hardware-details.md">イマーシブ ヘッドセット</a></th>
</tr><tr>
<td>MR 共有 250:HoloLens とイマーシブヘッドセット</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"> ✔️</td>
</tr>
</table>

## <a name="before-you-start"></a>開始前の準備

### <a name="prerequisites"></a>必須コンポーネント

* Windows 10 PC。[必要な開発ツール](install-the-tools.md)があり、 [windows Mixed Reality のイマーシブヘッドセットをサポートするように構成され](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines)ています。
* PC で動作する Xbox コントローラー。
* 少なくとも1つの HoloLens デバイスと1つのイマーシブヘッドセット。
* 検出のために UDP ブロードキャストを許可するネットワーク。

### <a name="project-files"></a>プロジェクトファイル

* プロジェクトに必要な[ファイル](https://github.com/Microsoft/MixedReality250/archive/master.zip)をダウンロードします。 覚えやすい場所にファイルを抽出します。
* このプロジェクトには、 [Windows Mixed Reality サポートを備えた Unity の推奨バージョン](install-the-tools.md)が必要です。

>[!NOTE]
>ダウンロードする前にソースコードを確認する場合は、GitHub から[入手でき](https://github.com/Microsoft/MixedReality250)ます。

## <a name="chapter-1---holo-world"></a>Chapter 1-Holo World

>[!VIDEO https://www.youtube.com/embed/IC0rp6rLiEc]

### <a name="objectives"></a>目的

開発環境が簡単なプロジェクトで準備できることを確認します。

### <a name="what-we-will-build"></a>ビルドする内容

HoloLens または Windows Mixed Reality イマーシブヘッドセットのホログラムを表示するアプリケーション。

### <a name="steps"></a>手順
* Unity を開きます。
    * **[開く]** を選択します。
    * プロジェクトファイルを抽出した場所に移動します。
    * **[フォルダーの選択]** をクリックします。
    * *Unity が初めてプロジェクトを処理するのに少し時間がかかります。*
* Unity で Mixed Reality が有効になっていることを確認します。
    * [ビルドの設定] ダイアログを開きます (ctrl **+ Shift + B**または**ファイル > ビルド設定...** )。
    * [**ユニバーサル Windows プラットフォーム**] を選択し、[**プラットフォームの切り替え**] をクリックします。
    * [ **> プレーヤー設定の編集**] を選択します。
    * 右側の [**インスペクター** ] パネルで、[ **XR Settings**] を展開します。
    * [**サポートされている仮想現実**] ボックスをオンにします。
    * *Windows Mixed Reality は、Virtual Reality SDK である必要があります。*
* シーンを作成します。
    * **階層**で、[**メインカメラ**] を右クリックし、[**削除**] を選択します。
    * **HoloToolkit > 入力 >** から、 **MixedRealityCameraParent**を**階層**にドラッグします。
* ホログラムをシーンに追加する
    * **AppPrefabs**から [**スカイ**ボックス] を [**シーン] ビュー**にドラッグします。
    * **AppPrefabs** **をドラッグし**て、**階層**に移動します。
    * **AppPrefabs**を**階層構造** **にドラッグし**ます。
* 保存とビルド
    * 保存 (**コントロール + S**または**ファイル > シーンの保存**)
    * これは新しいシーンであるため、名前を指定する必要があります。 名前は関係ありませんが、SharedMixedReality を使用します。
* Visual Studio へのエクスポート
    * [ビルド] メニューを開く (ctrl **+ Shift + B**または**ファイル > ビルド設定**)
    * [**開いているシーンの追加] をクリックします。**
    * **Unity C#プロジェクト**を確認する
    * **[Build]** をクリックします。
    * 表示された [エクスプローラー] ウィンドウで、 **App**という名前の新しいフォルダーを作成します。
    * **アプリ**フォルダーをシングルクリックします。
    * **[フォルダーの選択] をクリックします。**
    * **ビルドが完了するのを待ちます。**
    * 表示された [エクスプローラー] ウィンドウで、**アプリ**フォルダーに移動します。
    * SharedMixedReality をダブルクリックして Visual Studio を起動し**ます。**
* Visual Studio からビルドする
    * 上部のツールバーを使用して、target を**Release**および**x86**に変更します。
    * [**ローカルコンピューター** ] の横にある矢印をクリックし、[**デバイス**] を選択して HoloLens に展開します。
    * [**デバイス**] の横にある矢印をクリックし、mixed reality ヘッドセット用にデプロイする [**ローカルコンピューター** ] を選択します。
    * [**デバッグ]、[デバッグなしで開始**] の順にクリック >、 **F5 キーを押し**てアプリケーションを起動します。

### <a name="digging-into-the-code"></a>コードの調査

[プロジェクト] パネルで、 **Assets\HoloToolkit\Input\Scripts\Utilities**に移動し、[ **MixedRealityCameraManager.cs** ] をダブルクリックして開きます。

**概要**MixedRealityCameraManager.cs は、デバイスに基づいて品質レベルと背景の設定を調整する単純なスクリプトです。 ここで重要なのは HolographicSettings です。これにより、デバイスが HoloLens (IsDisplayOpaque 返し false) であるかイマーシブヘッドセット (IsDisplayOpaque 返し) であるかをスクリプトで検出できます。

### <a name="enjoy-your-progress"></a>進捗を楽しんでください

この時点で、アプリケーションはホログラムをレンダリングします。 このホログラムには、後で相互作用を追加します。 両方のデバイスが、ホログラムを同じようにレンダリングします。 また、イマーシブヘッドセットは、ブルースカイと雲の背景もレンダリングします。

## <a name="chapter-2---interaction"></a>Chapter 2-相互作用

>[!VIDEO https://www.youtube.com/embed/Lrb1y4sQRvI]

### <a name="objectives"></a>目的

Windows Mixed Reality アプリケーションの入力を処理する方法について説明します。

### <a name="what-we-will-build"></a>ビルドする内容

第1章のアプリケーションを基にして、ユーザーがホログラムを選択して、アプリを HoloLens またはイマーシブヘッドセットの仮想テーブルに配置できるようにする機能を追加します。

**入力リフレッシャー:** HoloLens では、選択ジェスチャは**エアタップ**です。 イマーシブヘッドセットでは、Xbox コントローラーの**A**ボタンを使用します。 入力の詳細について[は、こちら](gestures.md)を参照してください。

### <a name="steps"></a>手順
* 入力マネージャーの追加
    * **HoloToolkit > 入力 >** から、**管理者**の子として**inputmanager**を**階層**にドラッグします。
    * **HoloToolkit > 入力 > Prefabs > カーソル**を階層**に**ドラッグします。
* 空間マッピングの追加
    * **HoloToolkit > SpatialMapping から >** に**SpatialMapping**をドラッグします。
* 仮想再生空間の追加
    * **階層**内で**MixedRealityCameraParent**を**展開**します。
    * [**インスペクター** ] パネルで、[**境界**を有効にする] チェックボックスをオンにします。
    * **AppPrefabs**から、 **Vrroom**を**階層**にドラッグします。
* WorldAnchorManager の追加
    * [**階層**] で、[**マネージャー**] を選択します。
    * [**インスペクター**] で、[**コンポーネントの追加**] をクリックします。
    * 「**ワールドアンカーマネージャー**」と入力します。
    * [ **World Anchor Manager** ] を選択して追加します。
* TapToPlace を島に追加する
    * [**階層**] で [**アイランド**] を展開します。
    * [ **MixedRealityLand**] を選択します。
    * [**インスペクター**] で、[**コンポーネントの追加**] をクリックします。
    * 「 **Tap** 」と入力して選択します。
    * **タップ時に親を**確認します。
    * **配置オフセット**を **(0, 0.1, 0)** に設定します。
* 前と同じように保存してビルドします

### <a name="digging-into-the-code"></a>コードの調査

**スクリプト 1-GamepadInput.cs**

[プロジェクト] パネルで**Assets\HoloToolkit\Input\Scripts\InputSources**に移動し、[ **GamepadInput.cs** ] をダブルクリックして開きます。 [プロジェクト] パネルの同じパスで、[ **InteractionSourceInputSource.cs**] をダブルクリックします。

両方のスクリプトに共通の基本クラス BaseInputSource があることに注意してください。

BaseInputSource は、InputManager への参照を保持します。これにより、スクリプトでイベントをトリガーできます。 この場合、InputClicked イベントが関連しています。 これは、スクリプト2、TapToPlace にアクセスするときに注意する必要があります。 説明の入力の場合、押されたコントローラーのボタンをポーリングして、InputClicked イベントを発生させます。 InteractionSourceInputSource の場合、TappedEvent に応答して Inputクリックイベントを発生させます。

**スクリプト 2-TapToPlace.cs**

[プロジェクト] パネルで**Assets\HoloToolkit\SpatialMapping\Scripts**に移動し、[ **TapToPlace.cs** ] をダブルクリックして開きます。

Holographic アプリケーションを作成するときに、多くの開発者が実装する必要のある最初の作業は、ジェスチャ入力を使用したホログラムの移動です。 このように、このスクリプトを十分にコメントすることを endeavored しました。 このチュートリアルでは、いくつかの点に注目してください。

まず、TapToPlace は IInputClickHandler を実装することに注意してください。 IInputClickHandler は、GamePadInput.cs または InteractionSourceInputSource.cs によって発生した InputClicked イベントを処理する関数を公開します。 OnInputClicked は、TapToPlace を持つオブジェクトがフォーカスされているときに、BaseInputSource がクリックを検出したときに呼び出されます。 HoloLens で放送をタップするか、Xbox コントローラーの A ボタンを押すと、イベントがトリガーされます。

2番目の方法は、update では、surface が見られているかどうかを確認するために、テーブルのような画面にゲームオブジェクトを配置できるようにするコードです。 イマーシブヘッドセットには実際のサーフェイスの概念がないので、テーブルの上 (Vroom > TableSpatialMapping y > キューブ) を表すオブジェクトは、仮想テーブルの上にある上位の仮想テーブルと競合します。

### <a name="enjoy-your-progress"></a>進捗を楽しんでください

この時点で、移動する島を選択できます。 HoloLens では、島を実際の画面に移動できます。 イマーシブヘッドセットでは、追加した仮想テーブルに島を移動できます。

## <a name="chapter-3---sharing"></a>第3章-共有

>[!VIDEO https://www.youtube.com/embed/1diycJvxfDc]

### <a name="objectives"></a>目的

ネットワークが正しく構成されていること、およびデバイス間で空間アンカーがどのように共有されているかを確認します。

### <a name="what-we-will-build"></a>ビルドする内容

ここでは、プロジェクトをマルチプレイヤープロジェクトに変換します。 セッションをホストまたは参加させるための UI とロジックを追加します。 HoloLens ユーザーは、セッション内で、ヘッド上のクラウドと相互に表示されます。また、イマーシブヘッドセットユーザーは、アンカーがある場所の近くにクラウドを持っています。 イマーシブヘッドセットのユーザーには、シーンの発信元を基準とする HoloLens ユーザーが表示されます。 HoloLens ユーザーには、島のホログラムがすべて同じ場所に表示されます。 この章では、イマーシブヘッドセットのユーザーは島上にないことに注意してくださいが、HoloLens と非常によく似ていますが、島の目に見ていきます。

### <a name="steps"></a>手順
* 島と VRRoom の削除
    * **階層**内で**島**を右クリックし、[**削除**] を選択します。
    * **階層**で、[ **vrroom** ] を右クリックし、[**削除**] を選択します。
* Usland の追加
    * **AppPrefabs**から、**階層**に**usland**をドラッグします。
* **AppPrefabs**から、次の各を**階層**にドラッグします。
    * **UNETSharingStage**
    * **UNetAnchorRoot**
    * **UIContainer**
    * **DebugPanelButton**
* 前と同じように保存してビルドします

### <a name="digging-into-the-code"></a>コードの調査

[プロジェクト] パネルで、 **Assets\AppPrefabs\Support\SharingWithUnet\Scripts**に移動し、 **UnetAnchorManager.cs**をダブルクリックします。 1つの HoloLens が追跡情報を別の HoloLens と共有し、両方のデバイスが同じスペースを共有できるようにする機能は、ほぼ魔法のようなものです。 複数の人が同じデジタルデータを使用して共同作業を行うことができるようになると、mixed reality の威力が発揮されます。

このスクリプトでは、次の点に注意してください。

Start 関数で、 **Isdisplayopaque**のチェックに注意してください。 この例では、アンカーが確立されているとします。 これは、イマーシブヘッドセットがアンカーをインポートまたはエクスポートする方法を公開していないためです。 ただし、HoloLens で実行している場合は、このスクリプトによってデバイス間の共有アンカーが実装されます。 セッションを開始するデバイスでは、エクスポート用のアンカーが作成されます。 セッションを参加させるデバイスは、セッションを開始したデバイスからアンカーを要求します。

**エクスポート**

ユーザーがセッションを作成すると、NetworkDiscoveryWithAnchors は UNETAnchorManagers CreateAnchor 関数を呼び出します。 ここでは、CreateAnchor フローについて説明します。

まずは、前のアンカー用に収集したデータを消去して、いくつかの作業を行います。 次に、読み込むキャッシュされたアンカーがあるかどうかを確認します。 アンカーデータは 5 ~ 20 MB になる傾向があるため、キャッシュされたアンカーを再利用すると、ネットワーク経由で転送するために必要なデータ量を節約できます。 この方法については、後ほど説明します。 アンカーを再利用する場合でも、アンカーを持たない新しいクライアント結合の場合に備えてアンカーデータを準備する必要があります。

アンカーデータを準備することにより、WorldAnchorTransferBatch クラスは、別のデバイスまたはアプリケーションに送信するためのアンカーデータを準備する機能、およびアンカーデータをインポートする機能を公開します。 ここではエクスポートパスを利用しているため、アンカーを WorldAnchorTransferBatch に追加し、ExportAsync 関数を呼び出します。 ExportAsync は、エクスポートするデータを生成するときに、WriteBuffer コールバックを呼び出します。 すべてのデータがエクスポートされると、ExportComplete が呼び出されます。 WriteBuffer では、エクスポートのために保持しているリストにデータのチャンクを追加します。 ExportComplete で、リストを配列に変換します。 また、AnchorName 変数も設定されています。これにより、他のデバイスがアンカーを持っていない場合にその要求をトリガーします。

場合によっては、アンカーがエクスポートされない場合や、再作成するデータが少ない場合があります。 ここでは、CreateAnchor をもう一度呼び出します。

エクスポートパスの最後の関数は AnchorFoundRemotely です。 別のデバイスがアンカーを検出すると、そのデバイスはホストに通知します。ホストは、アンカーが "良好なアンカー" であり、キャッシュできることを示す信号としてそれを使用します。

**込ん**

HoloLens がセッションに参加する場合は、アンカーをインポートする必要があります。 UNETAnchorManager の Update 関数では、AnchorName がポーリングされます。 アンカー名が変更されると、インポートプロセスが開始されます。 まず、指定された名前のアンカーをローカルアンカーストアから読み込みます。 既にお持ちの場合は、データを再度ダウンロードすることなく使用できます。 そうでない場合は、WaitForAnchor を呼び出してダウンロードを開始します。

ダウンロードが完了すると、NetworkTransmitter_dataReadyEvent が呼び出されます。 これにより、ダウンロードしたデータを使用して、更新ループによって、更新プログラムが呼び出されます。 インポート処理が完了すると、ImportComplete が呼び出されます。 インポートが成功すると、アンカーはローカルのプレーヤーストアに保存されます。 PlayerController.cs は、適切なアンカーが確立されたことをホストに知らせるために、実際には AnchorFoundRemotely の呼び出しを行います。

### <a name="enjoy-your-progress"></a>進捗を楽しんでください

この時点で、HoloLens を使用するユーザーは、UI の [**セッションの開始**] ボタンを使用してセッションをホストします。 HoloLens またはイマーシブヘッドセットの両方で他のユーザーがセッションを選択し、UI の [**セッションに参加**] ボタンを選択します。 複数のユーザーが HoloLens デバイスを使用している場合は、そのヘッドに赤い雲があります。 また、イマーシブヘッドセットごとに青いクラウドもありますが、ヘッドホンが HoloLens デバイスと同じワールド座標空間を見つけようとしていないため、青い雲はヘッドセットの上にありません。

プロジェクト内のこのポイントは、含まれている共有アプリケーションです。それほど多くはありません。ベースラインとして機能する可能性があります。 次の章では、お客様にご利用いただけるエクスペリエンスの構築を開始します。 共有エクスペリエンスの設計に関する詳細なガイダンスについては、こちらを参照してください。

## <a name="chapter-4---immersion-and-teleporting"></a>第4章-Immersion と受付移植

>[!VIDEO https://www.youtube.com/embed/kUHZ5tCOfvY]

### <a name="objectives"></a>目的

さまざまな種類の mixed reality デバイスにエクスペリエンスを提供します。

### <a name="what-we-will-build"></a>ビルドする内容

アプリケーションを更新して、イマーシブビューを使用して、イマーシブヘッドセットユーザーを島に配置します。 HoloLens ユーザーには、島の概観が表示されます。 各デバイスの種類のユーザーは、世界中に表示されている他のユーザーを見ることができます。 たとえば、イマーシブヘッドセットユーザーは、島の他のパスで他のアバターを見ることができ、その島の上にジャイアントクラウドとして HoloLens ユーザーが表示されます。 イマーシブヘッドセットユーザーは、HoloLens ユーザーが島を見ている場合に、HoloLens ユーザーの宝石のカーソルも表示されます。 HoloLens ユーザーには、各イマーシブヘッドセットユーザーを表すアバターが島上に表示されます。

**イマーシブデバイスの入力が更新されました:**
* Xbox コントローラーの左バンパーボタンと右バンパーボタンは、プレーヤーを回転させます。
* Xbox コントローラーの Y ボタンを押すと、[テレポート](navigating-the-windows-mixed-reality-home.md#getting-around-your-home)カーソルが有効になります。 Y ボタンを離したときにカーソルの矢印インジケーターが回転している場合は、カーソルの位置に移動します。

### <a name="steps"></a>手順
* MixedRealityTeleport を MixedRealityCameraParent に追加する
    * [**階層**] で [ **usland**] を選択します。
    * **インスペクター**で、**レベルの制御**を有効にします。
    * [**階層**] で [ **MixedRealityCameraParent**] を選択します。
    * [**インスペクター**] で、[**コンポーネントの追加**] をクリックします。
    * 「 **Mixed Reality テレポート**」と入力して選択します。

### <a name="digging-into-the-code"></a>コードの調査

イマーシブヘッドセットユーザーはケーブルを使用して Pc にテザリングさされますが、この島はケーブルの長さが長いことを示しています。 補正するには、ユーザーの動きとは無関係にカメラを移動する機能が必要です。 Mixed reality アプリケーション (特に自己動きと locomotion) の設計の詳細については、[快適なページ](comfort.md)を参照してください。

このプロセスを説明するために、2つの用語を定義すると便利です。 まず、 **dolly**は、ユーザーとは別にカメラを移動するオブジェクトになります。 **Dolly**の子ゲームオブジェクトが**メインカメラ**になります。 メインカメラは、ユーザーの先頭に接続されています。

[プロジェクト] パネルで、 **Assets\AppPrefabs\Support\Scripts\GameLogic**に移動し、 **MixedRealityTeleport.cs**をダブルクリックします。

MixedRealityTeleport には2つのジョブがあります。 まず、バンパーを使用して回転を処理します。 Update 関数では、左バンパーと右バンパーの "ButtonUp" をポーリングします。 GetButtonUp は、最初のフレームに対してのみ true を返します。ボタンはダウンした後に起動します。 いずれかのボタンが発生した場合は、ユーザーを回転させる必要があることがわかります。

回転を行うときは、"フェードコントロール" と呼ばれる単純なスクリプトを使用してフェードアウトし、フェードインします。 これは、不快感につながる可能性がある不自然な動きをユーザーが見られないようにするためです。 フェードインとフェード効果は非常に単純です。 **メインカメラ**の前面に黒いクワッドがハングしています。 フェードアウトすると、アルファ値は0から1に移行されます。 これにより、クワッドの黒いピクセルが徐々にレンダリングされ、その背後に隠れる部分が見えなくなります。 フェードバック時に、アルファ値を0に戻します。

回転を計算するときは、 **dolly**を回転させながら、**メインカメラ**の回転を計算することに注意してください。 これは、**メインカメラ**が0、0、0から離れているほど正確ではありません。これは、dolly の周りの回転がユーザーの観点から見た場合に発生します。 実際、カメラの位置を中心に回転しない場合、ユーザーは回転ではなく、 **dolly**の周りの弧を移動します。

MixedRealityTeleport の2番目のジョブは、 **dolly**の移動を処理します。 これは SetWorldPosition で行われます。 SetWorldPosition は、目的の世界の位置、つまりユーザーがモックした位置を取得します。 このオフセットはフレームごとに追加されるので、その位置から**メインカメラ**のローカル位置を引いた位置に**dolly**を配置する必要があります。

2番目のスクリプトは SetWorldPosition を呼び出します。 そのスクリプトを見てみましょう。 [プロジェクト] パネルで、 **Assets\AppPrefabs\Support\Scripts\GameLogic**に移動し、 **TeleportScript.cs**をダブルクリックします。

このスクリプトは、MixedRealityTeleport よりも少し複雑です。 このスクリプトでは、停止する Xbox コントローラーの Y ボタンがあるかどうかを確認しています。 このボタンが押されている間、テレポートカーソルが表示され、スクリプトはユーザーの見つめ位置から射線をキャストします。 その光線が、上向きまたは小さいサーフェイスと競合している場合、その表面は、テレポートするのに適切なサーフェイスと見なされ、テレポートカーソルのアニメーションが有効になります。 射線が上向きまたは低いサーフェイスと競合しない場合、カーソルのアニメーションは無効になります。 Y ボタンが離され、射線の計算されたポイントが有効な位置である場合、このスクリプトは、射線が交差する位置を使用して SetWorldPosition を呼び出します。

### <a name="enjoy-your-progress"></a>進捗を楽しんでください

今回は、友人を見つける必要があります。

この場合も、HoloLens を使用するユーザーはセッションをホストします。 他のユーザーがセッションに参加します。 このアプリケーションでは、最初の3人のユーザーを、島の3つのパスのいずれかにあるイマーシブヘッドセットから結合するように配置します。 このセクションでは、島を自由に調べることができます。

注意事項:
1. クラウド内の顔を見ることができます。これにより、専念ユーザーは、HoloLens ユーザーが見ている方向を見ることができます。
2. 島のアバターには、回転する necks があります。 ユーザーが行っていることは、実際にはありませんが (この情報はありません)、快適なエクスペリエンスを実現します。
3. HoloLens ユーザーが島を見ている場合、専念ユーザーはカーソルを見ることができます。
4. ユーザーがシャドウをキャストする HoloLens を表すクラウド。

## <a name="chapter-5---finale"></a>章 5-くくり

>[!VIDEO https://www.youtube.com/embed/n_HDWJbfpNg]

### <a name="objectives"></a>目的

2つのデバイスの種類の間にコラボレーションによる対話型エクスペリエンスを作成します。

### <a name="what-we-will-build"></a>ビルドする内容

第4章では、イマーシブヘッドセットを使用しているユーザーが島のパズルの近くにいる場合、HoloLens ユーザーには、パズルの手掛かりとなるツールヒントが表示されます。 すべてのイマーシブヘッドセットユーザーがパズルを越えて、ロケット部屋の "ready pad" に戻ると、ロケットが起動します。

### <a name="steps"></a>手順
* [**階層**] で [ **usland**] を選択します。
* **インスペクター**の**レベルコントロール**で、[**コラボレーションを有効にする**] チェックボックスをオンにします。

### <a name="digging-into-the-code"></a>コードの調査

では、LevelControl.cs を見てみましょう。 このスクリプトはゲームロジックの中核であり、ゲームの状態を維持します。 これは UNET を使用するマルチプレイヤーゲームであるため、少なくともこのチュートリアルを変更するのに十分なデータフローを理解する必要があります。 UNET の概要については、Unity のドキュメントを参照してください。

[プロジェクト] パネルで、 **Assets\AppPrefabs\Support\Scripts\GameLogic**に移動し、 **LevelControl.cs**をダブルクリックします。

イマーシブヘッドセットがロケット起動の準備ができていることを示す方法を説明します。 ロケット起動の準備状態は、3つのブールのいずれかを島の3つのパスに対応するブールの一覧に設定することによって伝達されます。 パスに割り当てられたユーザーが、ロケット部屋内の茶色のパッドの上にあるときに、パスの bool が設定されます。 では、詳細について説明します。

Update () 関数で開始します。 "カンニング" 関数があることを確認します。 これを開発で使用して、ロケットの起動とリセットのシーケンスをテストしています。 複数のユーザーエクスペリエンスでは機能しません。 次のような情報を内在化たときに、うまくいくことができます。 どうしたらよいかを確認したら、ローカルプレーヤーが専念かどうかを確認します。 私たちは、目標を達成していることを確認したいと考えています。 If (専念) チェックの内部では、 **EnableCollaboration** bool の背後にある checkgoal が非表示になっています。 これは、この章の手順を完了している間にチェックしたチェックボックスに対応しています。 EnableCollaboration の中に、CheckGoal () の呼び出しが表示されます。

CheckGoal では、パッドの表示が大きくなっているか少ないかを調べることができます。 このような場合は、"目標に到達しました" というログを記録し、"Sendatゴール Message ()" というメッセージを呼び出します。 Sendatゴール Message で、playerController を呼び出します。 時間を節約するために、次のコードを使用します。

```cs
private void CmdSendAtGoal(int GoalIndex)
       {
           levelState.SetGoalIndex(GoalIndex);
       }
```

```cs
public void SendAtGoal(int GoalIndex)
       {
           if (isLocalPlayer)
           {
               Debug.Log("sending at goal " + GoalIndex);
               CmdSendAtGoal(GoalIndex);
           }
       }
```

Sendatゴールメッセージは CmdSendAtGoal を呼び出します。これは LevelControl.cs に戻された levelState. Setゴール Index を呼び出します。 一見すると、これは奇妙なように見えます。 ここでは、プレーヤーコントローラーを介したこの奇妙なルーティングではなく、SetGoalIndex を呼び出すことができないのはなぜですか。 これは、データの同期を維持するために UNET が使用するデータモデルに準拠しているためです。不正行為とスラッシングを防ぐため、UNET では、同期された変数を変更する権限を持つユーザーを各オブジェクトが持っている必要があります。 さらに、ホスト (セッションを開始したユーザー) のみがデータを直接変更できます。 ホストではないが権限を持っているユーザーは、ホストに "コマンド" を送信して変数を変更する必要があります。 既定では、ホストには、ユーザーを表すために生成されたオブジェクトを除き、すべてのオブジェクトに対する権限があります。 この例では、このオブジェクトには playercontroller スクリプトが含まれています。 オブジェクトの権限を要求してから変更を加える方法はありますが、プレーヤーコントローラーが自己権限を持ち、プレーヤーコントローラーを介してコマンドをルーティングするという事実を活用することを選択します。

もう1つの方法として、この目標を達成した場合、プレーヤーはホストに指示する必要があり、ホストは他のユーザーに通知する必要があります。

LevelControl.cs を参照してください。 ここでは、synclist (AtGoal) で値の値を設定しています。 これはホストのコンテキストであることに注意してください。 コマンドと同様に、RPC とは、すべてのクライアントがいくつかのコードを実行するためにホストが発行できるものです。 ここでは、' RpcCheckAllGoals ' を呼び出します。 各クライアントは、3つの AtGoals がすべて設定されているかどうかを個別に確認し、存在する場合はロケットを起動します。

### <a name="enjoy-your-progress"></a>進捗を楽しんでください

前の章では、前と同じようにセッションを開始します。 今回は、イマーシブヘッドセットのユーザーがパスの "ドア" に到達すると、HoloLens ユーザーのみが表示できるツールヒントが表示されます。 HoloLens ユーザーは、この手掛かりをイマーシブヘッドセット内のユーザーに伝える役割を担います。 各アバターが火山内の対応するブラウンパッドにステップインすると、ロケットがスペースで起動します。 シーンは60秒後にリセットされるので、再度行うことができます。

## <a name="see-also"></a>関連項目
* [MR 入力 213:モーション コントローラー](mixed-reality-213.md)
