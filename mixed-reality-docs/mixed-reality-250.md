---
title: MR 共有 250-HoloLens とイマーシブヘッドセット
description: Unity、Visual Studio、HoloLens、および Windows Mixed Reality ヘッドセットを使用したこのコーディングチュートリアルに従って、mixed reality デバイス間でのホログラムの共有の詳細を確認してください。
author: keveleigh
ms.author: kurtie
ms.date: 03/21/2018
ms.topic: article
keywords: holotoolkit、mixedrealitytoolkit、mixedrealitytoolkit、イマーシブ、motion controller、共有、xbox コントローラー、ネットワーク、クロスデバイス
ms.openlocfilehash: 9e1cb0d168b8bf830b4477190516cd19caef7972
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/24/2019
ms.locfileid: "63506116"
---
>[!NOTE]
><span data-ttu-id="d1121-104">Mixed Reality Academy チュートリアルは、HoloLens (第1世代) と Mixed Reality イマーシブヘッドセットを念頭に置いて設計されています。</span><span class="sxs-lookup"><span data-stu-id="d1121-104">The Mixed Reality Academy tutorials were designed with HoloLens (1st gen) and Mixed Reality Immersive Headsets in mind.</span></span>  <span data-ttu-id="d1121-105">そのため、これらのデバイスの開発に関するガイダンスをまだ探している開発者には、これらのチュートリアルを残しておくことが重要です。</span><span class="sxs-lookup"><span data-stu-id="d1121-105">As such, we feel it is important to leave these tutorials in place for developers who are still looking for guidance in developing for those devices.</span></span>  <span data-ttu-id="d1121-106">これらのチュートリアルは **_いない_** 最新のツールセットや相互作用が使用されている HoloLens 2 で更新されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-106">These tutorials will **_not_** be updated with the latest toolsets or interactions being used for HoloLens 2.</span></span>  <span data-ttu-id="d1121-107">サポートされているデバイスでの作業を続行するために管理されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-107">They will be maintained to continue working on the supported devices.</span></span> <span data-ttu-id="d1121-108">今後、HoloLens 2 向けの開発方法を示す新しい一連のチュートリアルが掲載されています。</span><span class="sxs-lookup"><span data-stu-id="d1121-108">There will be a new series of tutorials that will be posted in the future that will demonstrate how to develop for HoloLens 2.</span></span>  <span data-ttu-id="d1121-109">この通知は、これらのチュートリアルが投稿されたときのリンクと共に更新されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-109">This notice will be updated with a link to those tutorials when they are posted.</span></span>

<br>

# <a name="mr-sharing-250-hololens-and-immersive-headsets"></a><span data-ttu-id="d1121-110">MR 共有 250:HoloLens とイマーシブヘッドセット</span><span class="sxs-lookup"><span data-stu-id="d1121-110">MR Sharing 250: HoloLens and immersive headsets</span></span>

<span data-ttu-id="d1121-111">ユニバーサル Windows プラットフォーム (UWP) の柔軟性により、複数のデバイスにまたがるアプリケーションを簡単に作成できます。</span><span class="sxs-lookup"><span data-stu-id="d1121-111">With the flexibility of Universal Windows Platform (UWP), it is easy to create an application that spans multiple devices.</span></span> <span data-ttu-id="d1121-112">この柔軟性により、各デバイスの強みを活用するエクスペリエンスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="d1121-112">With this flexibility, we can create experiences that leverage the strengths of each device.</span></span> <span data-ttu-id="d1121-113">このチュートリアルでは、HoloLens と Windows Mixed Reality の両方のイマーシブヘッドセットで実行される基本的な共有エクスペリエンスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="d1121-113">This tutorial will cover a basic shared experience that runs on both HoloLens and Windows Mixed Reality immersive headsets.</span></span> <span data-ttu-id="d1121-114">このコンテンツはもともと、ワシントン州シアトルの Microsoft Build 2017 カンファレンスで配信されました。</span><span class="sxs-lookup"><span data-stu-id="d1121-114">This content was originally delivered at the Microsoft Build 2017 conference in Seattle, WA.</span></span>

<span data-ttu-id="d1121-115">**このチュートリアルでは、次のことについて説明します。**</span><span class="sxs-lookup"><span data-stu-id="d1121-115">**In this tutorial, we will:**</span></span>

* <span data-ttu-id="d1121-116">UNET を使用してネットワークをセットアップします。</span><span class="sxs-lookup"><span data-stu-id="d1121-116">Setup a network using UNET.</span></span>
* <span data-ttu-id="d1121-117">混合の現実のデバイス間でホログラムを共有します。</span><span class="sxs-lookup"><span data-stu-id="d1121-117">Share holograms across mixed reality devices.</span></span>
* <span data-ttu-id="d1121-118">使用されている mixed reality デバイスに応じて、アプリケーションの別のビューを確立します。</span><span class="sxs-lookup"><span data-stu-id="d1121-118">Establish a different view of the application depending on which mixed reality device is being used.</span></span>
* <span data-ttu-id="d1121-119">HoloLens ユーザーが、いくつかの単純なパズルを通じてユーザーをイマーシブヘッドセットに導く共有エクスペリエンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="d1121-119">Create a shared experience where HoloLens users guide immersive headsets users through some simple puzzles.</span></span>

## <a name="device-support"></a><span data-ttu-id="d1121-120">デバイスのサポート</span><span class="sxs-lookup"><span data-stu-id="d1121-120">Device support</span></span>

<table>
<tr>
<th><span data-ttu-id="d1121-121">まで</span><span class="sxs-lookup"><span data-stu-id="d1121-121">Course</span></span></th><th style="width:150px"> <span data-ttu-id="d1121-122"><a href="hololens-hardware-details.md">HoloLens</a></span><span class="sxs-lookup"><span data-stu-id="d1121-122"><a href="hololens-hardware-details.md">HoloLens</a></span></span></th><th style="width:150px"> <span data-ttu-id="d1121-123"><a href="immersive-headset-hardware-details.md">イマーシブ ヘッドセット</a></span><span class="sxs-lookup"><span data-stu-id="d1121-123"><a href="immersive-headset-hardware-details.md">Immersive headsets</a></span></span></th>
</tr><tr>
<td><span data-ttu-id="d1121-124">MR 共有 250:HoloLens とイマーシブヘッドセット</span><span class="sxs-lookup"><span data-stu-id="d1121-124">MR Sharing 250: HoloLens and immersive headsets</span></span></td><td style="text-align: center;"> <span data-ttu-id="d1121-125">✔️</span><span class="sxs-lookup"><span data-stu-id="d1121-125">✔️</span></span></td><td style="text-align: center;"> <span data-ttu-id="d1121-126">✔️</span><span class="sxs-lookup"><span data-stu-id="d1121-126">✔️</span></span></td>
</tr>
</table>

## <a name="before-you-start"></a><span data-ttu-id="d1121-127">開始前の準備</span><span class="sxs-lookup"><span data-stu-id="d1121-127">Before you start</span></span>

### <a name="prerequisites"></a><span data-ttu-id="d1121-128">必須コンポーネント</span><span class="sxs-lookup"><span data-stu-id="d1121-128">Prerequisites</span></span>

* <span data-ttu-id="d1121-129">Windows 10 PC。[必要な開発ツール](install-the-tools.md)があり、 [windows Mixed Reality のイマーシブヘッドセットをサポートするように構成され](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines)ています。</span><span class="sxs-lookup"><span data-stu-id="d1121-129">A Windows 10 PC with the [necessary development tools](install-the-tools.md) and [configured to support a Windows Mixed Reality immersive headset](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines).</span></span>
* <span data-ttu-id="d1121-130">PC で動作する Xbox コントローラー。</span><span class="sxs-lookup"><span data-stu-id="d1121-130">An Xbox controller that works with your PC.</span></span>
* <span data-ttu-id="d1121-131">少なくとも1つの HoloLens デバイスと1つのイマーシブヘッドセット。</span><span class="sxs-lookup"><span data-stu-id="d1121-131">At least one HoloLens device and one immersive headset.</span></span>
* <span data-ttu-id="d1121-132">検出のために UDP ブロードキャストを許可するネットワーク。</span><span class="sxs-lookup"><span data-stu-id="d1121-132">A network which allows UDP Broadcast for discovery.</span></span>

### <a name="project-files"></a><span data-ttu-id="d1121-133">プロジェクトファイル</span><span class="sxs-lookup"><span data-stu-id="d1121-133">Project files</span></span>

* <span data-ttu-id="d1121-134">プロジェクトに必要な[ファイル](https://github.com/Microsoft/MixedReality250/archive/master.zip)をダウンロードします。</span><span class="sxs-lookup"><span data-stu-id="d1121-134">Download the [files](https://github.com/Microsoft/MixedReality250/archive/master.zip) required by the project.</span></span> <span data-ttu-id="d1121-135">覚えやすい場所にファイルを抽出します。</span><span class="sxs-lookup"><span data-stu-id="d1121-135">Extract the files to an easy to remember location.</span></span>
* <span data-ttu-id="d1121-136">このプロジェクトには、 [Windows Mixed Reality サポートを備えた Unity の推奨バージョン](install-the-tools.md)が必要です。</span><span class="sxs-lookup"><span data-stu-id="d1121-136">This project requires the [a recommended version of Unity with Windows Mixed Reality support](install-the-tools.md).</span></span>

>[!NOTE]
><span data-ttu-id="d1121-137">ダウンロードする前にソースコードを確認する場合は、GitHub から[入手でき](https://github.com/Microsoft/MixedReality250)ます。</span><span class="sxs-lookup"><span data-stu-id="d1121-137">If you want to look through the source code before downloading, it's [available on GitHub](https://github.com/Microsoft/MixedReality250).</span></span>

## <a name="chapter-1---holo-world"></a><span data-ttu-id="d1121-138">Chapter 1-Holo World</span><span class="sxs-lookup"><span data-stu-id="d1121-138">Chapter 1 - Holo World</span></span>

>[!VIDEO https://www.youtube.com/embed/IC0rp6rLiEc]

### <a name="objectives"></a><span data-ttu-id="d1121-139">目的</span><span class="sxs-lookup"><span data-stu-id="d1121-139">Objectives</span></span>

<span data-ttu-id="d1121-140">開発環境が簡単なプロジェクトで準備できることを確認します。</span><span class="sxs-lookup"><span data-stu-id="d1121-140">Make sure the development environment is ready to go with a simple project.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="d1121-141">ビルドする内容</span><span class="sxs-lookup"><span data-stu-id="d1121-141">What we will build</span></span>

<span data-ttu-id="d1121-142">HoloLens または Windows Mixed Reality イマーシブヘッドセットのホログラムを表示するアプリケーション。</span><span class="sxs-lookup"><span data-stu-id="d1121-142">An application that shows a hologram on either HoloLens or a Windows Mixed Reality immersive headset.</span></span>

### <a name="steps"></a><span data-ttu-id="d1121-143">手順</span><span class="sxs-lookup"><span data-stu-id="d1121-143">Steps</span></span>
* <span data-ttu-id="d1121-144">Unity を開きます。</span><span class="sxs-lookup"><span data-stu-id="d1121-144">Open Unity.</span></span>
    * <span data-ttu-id="d1121-145">**[開く]** を選択します。</span><span class="sxs-lookup"><span data-stu-id="d1121-145">Select **Open**.</span></span>
    * <span data-ttu-id="d1121-146">プロジェクトファイルを抽出した場所に移動します。</span><span class="sxs-lookup"><span data-stu-id="d1121-146">Navigate to where you extracted the project files.</span></span>
    * <span data-ttu-id="d1121-147">**[フォルダーの選択]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="d1121-147">Click **Select Folder**.</span></span>
    * <span data-ttu-id="d1121-148">*Unity が初めてプロジェクトを処理するのに少し時間がかかります。*</span><span class="sxs-lookup"><span data-stu-id="d1121-148">*It will take a little while for Unity to process the project the first time.*</span></span>
* <span data-ttu-id="d1121-149">Unity で Mixed Reality が有効になっていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="d1121-149">Check that Mixed Reality is enabled in Unity.</span></span>
    * <span data-ttu-id="d1121-150">[ビルドの設定] ダイアログを開きます (ctrl **+ Shift + B**または**ファイル > ビルド設定...** )。</span><span class="sxs-lookup"><span data-stu-id="d1121-150">Open the build settings dialog (**Control+Shift+B** or **File > Build Settings...**).</span></span>
    * <span data-ttu-id="d1121-151">[**ユニバーサル Windows プラットフォーム**] を選択し、[**プラットフォームの切り替え**] をクリックします。</span><span class="sxs-lookup"><span data-stu-id="d1121-151">Select **Universal Windows Platform** then click **Switch Platform**.</span></span>
    * <span data-ttu-id="d1121-152">[ **> プレーヤー設定の編集**] を選択します。</span><span class="sxs-lookup"><span data-stu-id="d1121-152">Select **Edit>Player Settings**.</span></span>
    * <span data-ttu-id="d1121-153">右側の [**インスペクター** ] パネルで、[ **XR Settings**] を展開します。</span><span class="sxs-lookup"><span data-stu-id="d1121-153">In the **Inspector** panel on the right hand side, expand **XR Settings**.</span></span>
    * <span data-ttu-id="d1121-154">[**サポートされている仮想現実**] ボックスをオンにします。</span><span class="sxs-lookup"><span data-stu-id="d1121-154">Check the **Virtual Reality Supported** box.</span></span>
    * <span data-ttu-id="d1121-155">*Windows Mixed Reality は、Virtual Reality SDK である必要があります。*</span><span class="sxs-lookup"><span data-stu-id="d1121-155">*Windows Mixed Reality should be the Virtual Reality SDK.*</span></span>
* <span data-ttu-id="d1121-156">シーンを作成します。</span><span class="sxs-lookup"><span data-stu-id="d1121-156">Create a scene.</span></span>
    * <span data-ttu-id="d1121-157">**階層**で、[**メインカメラ**] を右クリックし、[**削除**] を選択します。</span><span class="sxs-lookup"><span data-stu-id="d1121-157">In the **Hierarchy** right click **Main Camera** select **Delete**.</span></span>
    * <span data-ttu-id="d1121-158">**HoloToolkit > 入力 >** から、 **MixedRealityCameraParent**を**階層**にドラッグします。</span><span class="sxs-lookup"><span data-stu-id="d1121-158">From **HoloToolkit > Input > Prefabs** drag **MixedRealityCameraParent** to the **Hierarchy**.</span></span>
* <span data-ttu-id="d1121-159">ホログラムをシーンに追加する</span><span class="sxs-lookup"><span data-stu-id="d1121-159">Add Holograms to the scene</span></span>
    * <span data-ttu-id="d1121-160">**AppPrefabs**から [**スカイ**ボックス] を [**シーン] ビュー**にドラッグします。</span><span class="sxs-lookup"><span data-stu-id="d1121-160">From **AppPrefabs** drag **Skybox** to the **Scene View**.</span></span>
    * <span data-ttu-id="d1121-161">**AppPrefabs** **をドラッグし**て、**階層**に移動します。</span><span class="sxs-lookup"><span data-stu-id="d1121-161">From **AppPrefabs** drag **Managers** to the **Hierarchy**.</span></span>
    * <span data-ttu-id="d1121-162">**AppPrefabs**を**階層構造** **にドラッグし**ます。</span><span class="sxs-lookup"><span data-stu-id="d1121-162">From **AppPrefabs** drag **Island** to the **Hierarchy**.</span></span>
* <span data-ttu-id="d1121-163">保存とビルド</span><span class="sxs-lookup"><span data-stu-id="d1121-163">Save And build</span></span>
    * <span data-ttu-id="d1121-164">保存 (**コントロール + S**または**ファイル > シーンの保存**)</span><span class="sxs-lookup"><span data-stu-id="d1121-164">Save (either **Control+S** or **File > Save Scene**)</span></span>
    * <span data-ttu-id="d1121-165">これは新しいシーンであるため、名前を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1121-165">Since this is a new scene, you'll need to name it.</span></span> <span data-ttu-id="d1121-166">名前は関係ありませんが、SharedMixedReality を使用します。</span><span class="sxs-lookup"><span data-stu-id="d1121-166">Name doesn't matter, but we use SharedMixedReality.</span></span>
* <span data-ttu-id="d1121-167">Visual Studio へのエクスポート</span><span class="sxs-lookup"><span data-stu-id="d1121-167">Export To Visual Studio</span></span>
    * <span data-ttu-id="d1121-168">[ビルド] メニューを開く (ctrl **+ Shift + B**または**ファイル > ビルド設定**)</span><span class="sxs-lookup"><span data-stu-id="d1121-168">Open the build menu (**Control+Shift+B** or **File > Build Settings**)</span></span>
    * <span data-ttu-id="d1121-169">[**開いているシーンの追加] をクリックします。**</span><span class="sxs-lookup"><span data-stu-id="d1121-169">Click **Add Open Scenes.**</span></span>
    * <span data-ttu-id="d1121-170">**Unity C#プロジェクト**を確認する</span><span class="sxs-lookup"><span data-stu-id="d1121-170">Check **Unity C# Projects**</span></span>
    * <span data-ttu-id="d1121-171">**[Build]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="d1121-171">Click **Build**.</span></span>
    * <span data-ttu-id="d1121-172">表示された [エクスプローラー] ウィンドウで、 **App**という名前の新しいフォルダーを作成します。</span><span class="sxs-lookup"><span data-stu-id="d1121-172">In the file explorer window that appears, create a New Folder named **App**.</span></span>
    * <span data-ttu-id="d1121-173">**アプリ**フォルダーをシングルクリックします。</span><span class="sxs-lookup"><span data-stu-id="d1121-173">Single click the **App** folder.</span></span>
    * <span data-ttu-id="d1121-174">**[フォルダーの選択] をクリックします。**</span><span class="sxs-lookup"><span data-stu-id="d1121-174">Press **Select Folder.**</span></span>
    * <span data-ttu-id="d1121-175">**ビルドが完了するのを待ちます。**</span><span class="sxs-lookup"><span data-stu-id="d1121-175">**Wait for the build to complete**</span></span>
    * <span data-ttu-id="d1121-176">表示された [エクスプローラー] ウィンドウで、**アプリ**フォルダーに移動します。</span><span class="sxs-lookup"><span data-stu-id="d1121-176">In the file explorer window that appears, navigate into the **App** folder.</span></span>
    * <span data-ttu-id="d1121-177">SharedMixedReality をダブルクリックして Visual Studio を起動し**ます。**</span><span class="sxs-lookup"><span data-stu-id="d1121-177">Double-click **SharedMixedReality.sln** to launch Visual Studio</span></span>
* <span data-ttu-id="d1121-178">Visual Studio からビルドする</span><span class="sxs-lookup"><span data-stu-id="d1121-178">Build From Visual Studio</span></span>
    * <span data-ttu-id="d1121-179">上部のツールバーを使用して、target を**Release**および**x86**に変更します。</span><span class="sxs-lookup"><span data-stu-id="d1121-179">Using the top toolbar change target to **Release** and **x86**.</span></span>
    * <span data-ttu-id="d1121-180">[**ローカルコンピューター** ] の横にある矢印をクリックし、[**デバイス**] を選択して HoloLens に展開します。</span><span class="sxs-lookup"><span data-stu-id="d1121-180">Click the arrow next to **Local Machine** and select **Device** to deploy to HoloLens</span></span>
    * <span data-ttu-id="d1121-181">[**デバイス**] の横にある矢印をクリックし、mixed reality ヘッドセット用にデプロイする [**ローカルコンピューター** ] を選択します。</span><span class="sxs-lookup"><span data-stu-id="d1121-181">Click the arrow next to **Device** and select **Local Machine** to deploy for the mixed reality headset.</span></span>
    * <span data-ttu-id="d1121-182">[**デバッグ]、[デバッグなしで開始**] の順にクリック >、 **F5 キーを押し**てアプリケーションを起動します。</span><span class="sxs-lookup"><span data-stu-id="d1121-182">Click **Debug->Start Without Debugging** or **Control+F5** to start the application.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="d1121-183">コードの調査</span><span class="sxs-lookup"><span data-stu-id="d1121-183">Digging into the code</span></span>

<span data-ttu-id="d1121-184">[プロジェクト] パネルで、 **Assets\HoloToolkit\Input\Scripts\Utilities**に移動し、[ **MixedRealityCameraManager.cs** ] をダブルクリックして開きます。</span><span class="sxs-lookup"><span data-stu-id="d1121-184">In the project panel, navigate to **Assets\HoloToolkit\Input\Scripts\Utilities** and double click **MixedRealityCameraManager.cs** to open it.</span></span>

<span data-ttu-id="d1121-185">**概要**MixedRealityCameraManager.cs は、デバイスに基づいて品質レベルと背景の設定を調整する単純なスクリプトです。</span><span class="sxs-lookup"><span data-stu-id="d1121-185">**Overview:** MixedRealityCameraManager.cs is a simple script that adjusts quality level and background settings based on the device.</span></span> <span data-ttu-id="d1121-186">ここで重要なのは HolographicSettings です。これにより、デバイスが HoloLens (IsDisplayOpaque 返し false) であるかイマーシブヘッドセット (IsDisplayOpaque 返し) であるかをスクリプトで検出できます。</span><span class="sxs-lookup"><span data-stu-id="d1121-186">Key here is HolographicSettings.IsDisplayOpaque, which allows a script to detect if the device is a HoloLens (IsDisplayOpaque returns false) or an immersive headset (IsDisplayOpaque returns true).</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="d1121-187">進捗を楽しんでください</span><span class="sxs-lookup"><span data-stu-id="d1121-187">Enjoy your progress</span></span>

<span data-ttu-id="d1121-188">この時点で、アプリケーションはホログラムをレンダリングします。</span><span class="sxs-lookup"><span data-stu-id="d1121-188">At this point the application will just render a hologram.</span></span> <span data-ttu-id="d1121-189">このホログラムには、後で相互作用を追加します。</span><span class="sxs-lookup"><span data-stu-id="d1121-189">We will add interaction to the hologram later.</span></span> <span data-ttu-id="d1121-190">両方のデバイスが、ホログラムを同じようにレンダリングします。</span><span class="sxs-lookup"><span data-stu-id="d1121-190">Both devices will render the hologram the same.</span></span> <span data-ttu-id="d1121-191">また、イマーシブヘッドセットは、ブルースカイと雲の背景もレンダリングします。</span><span class="sxs-lookup"><span data-stu-id="d1121-191">The immersive headset will also render a blue sky and clouds background.</span></span>

## <a name="chapter-2---interaction"></a><span data-ttu-id="d1121-192">Chapter 2-相互作用</span><span class="sxs-lookup"><span data-stu-id="d1121-192">Chapter 2 - Interaction</span></span>

>[!VIDEO https://www.youtube.com/embed/Lrb1y4sQRvI]

### <a name="objectives"></a><span data-ttu-id="d1121-193">目的</span><span class="sxs-lookup"><span data-stu-id="d1121-193">Objectives</span></span>

<span data-ttu-id="d1121-194">Windows Mixed Reality アプリケーションの入力を処理する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="d1121-194">Show how to handle input for a Windows Mixed Reality application.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="d1121-195">ビルドする内容</span><span class="sxs-lookup"><span data-stu-id="d1121-195">What we will build</span></span>

<span data-ttu-id="d1121-196">第1章のアプリケーションを基にして、ユーザーがホログラムを選択して、アプリを HoloLens またはイマーシブヘッドセットの仮想テーブルに配置できるようにする機能を追加します。</span><span class="sxs-lookup"><span data-stu-id="d1121-196">Building on the application from chapter 1, we will add functionality to allow the user to pick up the hologram and place it on a real world surface in HoloLens or on a virtual table in an immersive headset.</span></span>

<span data-ttu-id="d1121-197">**入力リフレッシャー:** HoloLens では、選択ジェスチャは**エアタップ**です。</span><span class="sxs-lookup"><span data-stu-id="d1121-197">**Input Refresher:** On HoloLens the select gesture is the **air tap**.</span></span> <span data-ttu-id="d1121-198">イマーシブヘッドセットでは、Xbox コントローラーの**A**ボタンを使用します。</span><span class="sxs-lookup"><span data-stu-id="d1121-198">On immersive headsets, we will use the **A** button on the Xbox controller.</span></span> <span data-ttu-id="d1121-199">入力の詳細について[は、こちら](gestures.md)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d1121-199">For more information on input [start here](gestures.md).</span></span>

### <a name="steps"></a><span data-ttu-id="d1121-200">手順</span><span class="sxs-lookup"><span data-stu-id="d1121-200">Steps</span></span>
* <span data-ttu-id="d1121-201">入力マネージャーの追加</span><span class="sxs-lookup"><span data-stu-id="d1121-201">Add Input manager</span></span>
    * <span data-ttu-id="d1121-202">**HoloToolkit > 入力 >** から、**管理者**の子として**inputmanager**を**階層**にドラッグします。</span><span class="sxs-lookup"><span data-stu-id="d1121-202">From **HoloToolkit > Input > Prefabs** drag **InputManager** to **Hierarchy** as a child of **Managers**.</span></span>
    * <span data-ttu-id="d1121-203">**HoloToolkit > 入力 > Prefabs > カーソル**を階層**に**ドラッグします。</span><span class="sxs-lookup"><span data-stu-id="d1121-203">From **HoloToolkit > Input > Prefabs > Cursor** drag **Cursor** to **Hierarchy**.</span></span>
* <span data-ttu-id="d1121-204">空間マッピングの追加</span><span class="sxs-lookup"><span data-stu-id="d1121-204">Add Spatial Mapping</span></span>
    * <span data-ttu-id="d1121-205">**HoloToolkit > SpatialMapping から >** に**SpatialMapping**をドラッグします。</span><span class="sxs-lookup"><span data-stu-id="d1121-205">From **HoloToolkit > SpatialMapping > Prefabs** drag **SpatialMapping** to **Hierarchy**.</span></span>
* <span data-ttu-id="d1121-206">仮想再生空間の追加</span><span class="sxs-lookup"><span data-stu-id="d1121-206">Add Virtual Playspace</span></span>
    * <span data-ttu-id="d1121-207">**階層**内で**MixedRealityCameraParent**を**展開**します。</span><span class="sxs-lookup"><span data-stu-id="d1121-207">In **Hierarchy** expand **MixedRealityCameraParent** select **Boundary**</span></span>
    * <span data-ttu-id="d1121-208">[**インスペクター** ] パネルで、[**境界**を有効にする] チェックボックスをオンにします。</span><span class="sxs-lookup"><span data-stu-id="d1121-208">In **Inspector** panel check the box to enable **Boundary**</span></span>
    * <span data-ttu-id="d1121-209">**AppPrefabs**から、 **Vrroom**を**階層**にドラッグします。</span><span class="sxs-lookup"><span data-stu-id="d1121-209">From **AppPrefabs** drag **VRRoom** to **Hierarchy**.</span></span>
* <span data-ttu-id="d1121-210">WorldAnchorManager の追加</span><span class="sxs-lookup"><span data-stu-id="d1121-210">Add WorldAnchorManager</span></span>
    * <span data-ttu-id="d1121-211">[**階層**] で、[**マネージャー**] を選択します。</span><span class="sxs-lookup"><span data-stu-id="d1121-211">In **Hierarchy**, Select **Managers**.</span></span>
    * <span data-ttu-id="d1121-212">[**インスペクター**] で、[**コンポーネントの追加**] をクリックします。</span><span class="sxs-lookup"><span data-stu-id="d1121-212">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="d1121-213">「**ワールドアンカーマネージャー**」と入力します。</span><span class="sxs-lookup"><span data-stu-id="d1121-213">Type **World Anchor Manager**.</span></span>
    * <span data-ttu-id="d1121-214">[ **World Anchor Manager** ] を選択して追加します。</span><span class="sxs-lookup"><span data-stu-id="d1121-214">Select **World Anchor Manager** to add it.</span></span>
* <span data-ttu-id="d1121-215">TapToPlace を島に追加する</span><span class="sxs-lookup"><span data-stu-id="d1121-215">Add TapToPlace to the Island</span></span>
    * <span data-ttu-id="d1121-216">[**階層**] で [**アイランド**] を展開します。</span><span class="sxs-lookup"><span data-stu-id="d1121-216">In **Hierarchy**, expand **Island**.</span></span>
    * <span data-ttu-id="d1121-217">[ **MixedRealityLand**] を選択します。</span><span class="sxs-lookup"><span data-stu-id="d1121-217">Select **MixedRealityLand**.</span></span>
    * <span data-ttu-id="d1121-218">[**インスペクター**] で、[**コンポーネントの追加**] をクリックします。</span><span class="sxs-lookup"><span data-stu-id="d1121-218">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="d1121-219">「 **Tap** 」と入力して選択します。</span><span class="sxs-lookup"><span data-stu-id="d1121-219">Type **Tap To Place** and select it.</span></span>
    * <span data-ttu-id="d1121-220">**タップ時に親を**確認します。</span><span class="sxs-lookup"><span data-stu-id="d1121-220">Check **Place Parent On Tap**.</span></span>
    * <span data-ttu-id="d1121-221">**配置オフセット**を **(0, 0.1, 0)** に設定します。</span><span class="sxs-lookup"><span data-stu-id="d1121-221">Set **Placement Offset** to **(0, 0.1, 0)**.</span></span>
* <span data-ttu-id="d1121-222">前と同じように保存してビルドします</span><span class="sxs-lookup"><span data-stu-id="d1121-222">Save and Build as before</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="d1121-223">コードの調査</span><span class="sxs-lookup"><span data-stu-id="d1121-223">Digging into the code</span></span>

<span data-ttu-id="d1121-224">**スクリプト 1-GamepadInput.cs**</span><span class="sxs-lookup"><span data-stu-id="d1121-224">**Script 1 - GamepadInput.cs**</span></span>

<span data-ttu-id="d1121-225">[プロジェクト] パネルで**Assets\HoloToolkit\Input\Scripts\InputSources**に移動し、[ **GamepadInput.cs** ] をダブルクリックして開きます。</span><span class="sxs-lookup"><span data-stu-id="d1121-225">In the project panel navigate to **Assets\HoloToolkit\Input\Scripts\InputSources** and double click **GamepadInput.cs** to open it.</span></span> <span data-ttu-id="d1121-226">[プロジェクト] パネルの同じパスで、[ **InteractionSourceInputSource.cs**] をダブルクリックします。</span><span class="sxs-lookup"><span data-stu-id="d1121-226">From the same path in the project panel, also double click **InteractionSourceInputSource.cs**.</span></span>

<span data-ttu-id="d1121-227">両方のスクリプトに共通の基本クラス BaseInputSource があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="d1121-227">Note that both scripts have a common base class, BaseInputSource.</span></span>

<span data-ttu-id="d1121-228">BaseInputSource は、InputManager への参照を保持します。これにより、スクリプトでイベントをトリガーできます。</span><span class="sxs-lookup"><span data-stu-id="d1121-228">BaseInputSource keeps a reference to an InputManager, which allows a script to trigger events.</span></span> <span data-ttu-id="d1121-229">この場合、InputClicked イベントが関連しています。</span><span class="sxs-lookup"><span data-stu-id="d1121-229">In this case, the InputClicked event is relevant.</span></span> <span data-ttu-id="d1121-230">これは、スクリプト2、TapToPlace にアクセスするときに注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1121-230">This will be important to remember when we get to script 2, TapToPlace.</span></span> <span data-ttu-id="d1121-231">説明の入力の場合、押されたコントローラーのボタンをポーリングして、InputClicked イベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="d1121-231">In the case of GamePadInput, we poll for the A button on the controller to be pressed, then we raise the InputClicked event.</span></span> <span data-ttu-id="d1121-232">InteractionSourceInputSource の場合、TappedEvent に応答して Inputクリックイベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="d1121-232">In the case of InteractionSourceInputSource, we raise the InputClicked event in response to the TappedEvent.</span></span>

<span data-ttu-id="d1121-233">**スクリプト 2-TapToPlace.cs**</span><span class="sxs-lookup"><span data-stu-id="d1121-233">**Script 2 - TapToPlace.cs**</span></span>

<span data-ttu-id="d1121-234">[プロジェクト] パネルで**Assets\HoloToolkit\SpatialMapping\Scripts**に移動し、[ **TapToPlace.cs** ] をダブルクリックして開きます。</span><span class="sxs-lookup"><span data-stu-id="d1121-234">In the project panel navigate to **Assets\HoloToolkit\SpatialMapping\Scripts** and double click **TapToPlace.cs** to open it.</span></span>

<span data-ttu-id="d1121-235">Holographic アプリケーションを作成するときに、多くの開発者が実装する必要のある最初の作業は、ジェスチャ入力を使用したホログラムの移動です。</span><span class="sxs-lookup"><span data-stu-id="d1121-235">The first thing many developers want to implement when creating a Holographic application is moving Holograms with gesture input.</span></span> <span data-ttu-id="d1121-236">このように、このスクリプトを十分にコメントすることを endeavored しました。</span><span class="sxs-lookup"><span data-stu-id="d1121-236">As such, we've endeavored to thoroughly comment this script.</span></span> <span data-ttu-id="d1121-237">このチュートリアルでは、いくつかの点に注目してください。</span><span class="sxs-lookup"><span data-stu-id="d1121-237">A few things are worth highlighting for this tutorial.</span></span>

<span data-ttu-id="d1121-238">まず、TapToPlace は IInputClickHandler を実装することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="d1121-238">First, note that TapToPlace implements IInputClickHandler.</span></span> <span data-ttu-id="d1121-239">IInputClickHandler は、GamePadInput.cs または InteractionSourceInputSource.cs によって発生した InputClicked イベントを処理する関数を公開します。</span><span class="sxs-lookup"><span data-stu-id="d1121-239">IInputClickHandler exposes the functions that handle the InputClicked event raised by GamePadInput.cs or InteractionSourceInputSource.cs.</span></span> <span data-ttu-id="d1121-240">OnInputClicked は、TapToPlace を持つオブジェクトがフォーカスされているときに、BaseInputSource がクリックを検出したときに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-240">OnInputClicked is called when a BaseInputSource detects a click while the object with TapToPlace is in focus.</span></span> <span data-ttu-id="d1121-241">HoloLens で放送をタップするか、Xbox コントローラーの A ボタンを押すと、イベントがトリガーされます。</span><span class="sxs-lookup"><span data-stu-id="d1121-241">Either airtapping on HoloLens or pressing the A button on the Xbox controller will trigger the event.</span></span>

<span data-ttu-id="d1121-242">2番目の方法は、update では、surface が見られているかどうかを確認するために、テーブルのような画面にゲームオブジェクトを配置できるようにするコードです。</span><span class="sxs-lookup"><span data-stu-id="d1121-242">Second is the code be executed in update to see if a surface is being looked at so we can place the game object on a surface, like a table.</span></span> <span data-ttu-id="d1121-243">イマーシブヘッドセットには実際のサーフェイスの概念がないので、テーブルの上 (Vroom > TableSpatialMapping y > キューブ) を表すオブジェクトは、仮想テーブルの上にある上位の仮想テーブルと競合します。</span><span class="sxs-lookup"><span data-stu-id="d1121-243">The immersive headset doesn't have a concept of real surfaces, so the object that represents the table top (Vroom > TableThingy > Cube) has been marked with the SpatialMapping physics layer, so the ray cast in Update will collide with the virtual table top.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="d1121-244">進捗を楽しんでください</span><span class="sxs-lookup"><span data-stu-id="d1121-244">Enjoy your progress</span></span>

<span data-ttu-id="d1121-245">この時点で、移動する島を選択できます。</span><span class="sxs-lookup"><span data-stu-id="d1121-245">This time you can select the island to move it.</span></span> <span data-ttu-id="d1121-246">HoloLens では、島を実際の画面に移動できます。</span><span class="sxs-lookup"><span data-stu-id="d1121-246">On HoloLens you can move the island to a real surface.</span></span> <span data-ttu-id="d1121-247">イマーシブヘッドセットでは、追加した仮想テーブルに島を移動できます。</span><span class="sxs-lookup"><span data-stu-id="d1121-247">In the immersive headset you can move the island to the virtual table we added.</span></span>

## <a name="chapter-3---sharing"></a><span data-ttu-id="d1121-248">第3章-共有</span><span class="sxs-lookup"><span data-stu-id="d1121-248">Chapter 3 - Sharing</span></span>

>[!VIDEO https://www.youtube.com/embed/1diycJvxfDc]

### <a name="objectives"></a><span data-ttu-id="d1121-249">目的</span><span class="sxs-lookup"><span data-stu-id="d1121-249">Objectives</span></span>

<span data-ttu-id="d1121-250">ネットワークが正しく構成されていること、およびデバイス間で空間アンカーがどのように共有されているかを確認します。</span><span class="sxs-lookup"><span data-stu-id="d1121-250">Ensure that the network is correctly configured and detail how spatial anchors are shared between devices.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="d1121-251">ビルドする内容</span><span class="sxs-lookup"><span data-stu-id="d1121-251">What we will build</span></span>

<span data-ttu-id="d1121-252">ここでは、プロジェクトをマルチプレイヤープロジェクトに変換します。</span><span class="sxs-lookup"><span data-stu-id="d1121-252">We will convert our project to a multiplayer project.</span></span> <span data-ttu-id="d1121-253">セッションをホストまたは参加させるための UI とロジックを追加します。</span><span class="sxs-lookup"><span data-stu-id="d1121-253">We will add UI and logic to host or join sessions.</span></span> <span data-ttu-id="d1121-254">HoloLens ユーザーは、セッション内で、ヘッド上のクラウドと相互に表示されます。また、イマーシブヘッドセットユーザーは、アンカーがある場所の近くにクラウドを持っています。</span><span class="sxs-lookup"><span data-stu-id="d1121-254">HoloLens users will see each other in the session with clouds over their heads, and immersive headset users have clouds near to where the anchor is.</span></span> <span data-ttu-id="d1121-255">イマーシブヘッドセットのユーザーには、シーンの発信元を基準とする HoloLens ユーザーが表示されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-255">Users in the immersive headsets will see the HoloLens users relative to the origin of the scene.</span></span> <span data-ttu-id="d1121-256">HoloLens ユーザーには、島のホログラムがすべて同じ場所に表示されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-256">HoloLens users will all see the hologram of the island in the same place.</span></span> <span data-ttu-id="d1121-257">この章では、イマーシブヘッドセットのユーザーは島上にないことに注意してくださいが、HoloLens と非常によく似ていますが、島の目に見ていきます。</span><span class="sxs-lookup"><span data-stu-id="d1121-257">It is key to note that the users in the immersive headsets will not be on the island during this chapter, but will behave very similarly to HoloLens, with a birds eye view of the island.</span></span>

### <a name="steps"></a><span data-ttu-id="d1121-258">手順</span><span class="sxs-lookup"><span data-stu-id="d1121-258">Steps</span></span>
* <span data-ttu-id="d1121-259">島と VRRoom の削除</span><span class="sxs-lookup"><span data-stu-id="d1121-259">Remove Island and VRRoom</span></span>
    * <span data-ttu-id="d1121-260">**階層**内で**島**を右クリックし、[**削除**] を選択します。</span><span class="sxs-lookup"><span data-stu-id="d1121-260">In **Hierarchy** right-click **Island** select **Delete**</span></span>
    * <span data-ttu-id="d1121-261">**階層**で、[ **vrroom** ] を右クリックし、[**削除**] を選択します。</span><span class="sxs-lookup"><span data-stu-id="d1121-261">In **Hierarchy** right-click **VRRoom** select **Delete**</span></span>
* <span data-ttu-id="d1121-262">Usland の追加</span><span class="sxs-lookup"><span data-stu-id="d1121-262">Add Usland</span></span>
    * <span data-ttu-id="d1121-263">**AppPrefabs**から、**階層**に**usland**をドラッグします。</span><span class="sxs-lookup"><span data-stu-id="d1121-263">From **AppPrefabs** drag **Usland** to **Hierarchy**.</span></span>
* <span data-ttu-id="d1121-264">**AppPrefabs**から、次の各を**階層**にドラッグします。</span><span class="sxs-lookup"><span data-stu-id="d1121-264">From **AppPrefabs** drag each of the following to **Hierarchy**:</span></span>
    * <span data-ttu-id="d1121-265">**UNETSharingStage**</span><span class="sxs-lookup"><span data-stu-id="d1121-265">**UNETSharingStage**</span></span>
    * <span data-ttu-id="d1121-266">**UNetAnchorRoot**</span><span class="sxs-lookup"><span data-stu-id="d1121-266">**UNetAnchorRoot**</span></span>
    * <span data-ttu-id="d1121-267">**UIContainer**</span><span class="sxs-lookup"><span data-stu-id="d1121-267">**UIContainer**</span></span>
    * <span data-ttu-id="d1121-268">**DebugPanelButton**</span><span class="sxs-lookup"><span data-stu-id="d1121-268">**DebugPanelButton**</span></span>
* <span data-ttu-id="d1121-269">前と同じように保存してビルドします</span><span class="sxs-lookup"><span data-stu-id="d1121-269">Save and Build as before</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="d1121-270">コードの調査</span><span class="sxs-lookup"><span data-stu-id="d1121-270">Digging into the code</span></span>

<span data-ttu-id="d1121-271">[プロジェクト] パネルで、 **Assets\AppPrefabs\Support\SharingWithUnet\Scripts**に移動し、 **UnetAnchorManager.cs**をダブルクリックします。</span><span class="sxs-lookup"><span data-stu-id="d1121-271">In the project panel, navigate to **Assets\AppPrefabs\Support\SharingWithUnet\Scripts** and double-click on **UnetAnchorManager.cs**.</span></span> <span data-ttu-id="d1121-272">1つの HoloLens が追跡情報を別の HoloLens と共有し、両方のデバイスが同じスペースを共有できるようにする機能は、ほぼ魔法のようなものです。</span><span class="sxs-lookup"><span data-stu-id="d1121-272">The ability for one HoloLens to share tracking information with another HoloLens such that both devices can share the same space is near magical.</span></span> <span data-ttu-id="d1121-273">複数の人が同じデジタルデータを使用して共同作業を行うことができるようになると、mixed reality の威力が発揮されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-273">The power of mixed reality comes alive when two or more people can collaborate using the same digital data.</span></span>

<span data-ttu-id="d1121-274">このスクリプトでは、次の点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="d1121-274">A few things to point out in this script:</span></span>

<span data-ttu-id="d1121-275">Start 関数で、 **Isdisplayopaque**のチェックに注意してください。</span><span class="sxs-lookup"><span data-stu-id="d1121-275">In the start function, notice the check for **IsDisplayOpaque**.</span></span> <span data-ttu-id="d1121-276">この例では、アンカーが確立されているとします。</span><span class="sxs-lookup"><span data-stu-id="d1121-276">In this case, we pretend that the Anchor is established.</span></span> <span data-ttu-id="d1121-277">これは、イマーシブヘッドセットがアンカーをインポートまたはエクスポートする方法を公開していないためです。</span><span class="sxs-lookup"><span data-stu-id="d1121-277">This is because the immersive headsets do not expose a way to import or export anchors.</span></span> <span data-ttu-id="d1121-278">ただし、HoloLens で実行している場合は、このスクリプトによってデバイス間の共有アンカーが実装されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-278">If we are running on a HoloLens, however, this script implements sharing anchors between the devices.</span></span> <span data-ttu-id="d1121-279">セッションを開始するデバイスでは、エクスポート用のアンカーが作成されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-279">The device that starts the session will create an anchor for exporting.</span></span> <span data-ttu-id="d1121-280">セッションを参加させるデバイスは、セッションを開始したデバイスからアンカーを要求します。</span><span class="sxs-lookup"><span data-stu-id="d1121-280">The device that joins a session will request the anchor from the device that started the session.</span></span>

<span data-ttu-id="d1121-281">**エクスポート**</span><span class="sxs-lookup"><span data-stu-id="d1121-281">**Exporting:**</span></span>

<span data-ttu-id="d1121-282">ユーザーがセッションを作成すると、NetworkDiscoveryWithAnchors は UNETAnchorManagers CreateAnchor 関数を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="d1121-282">When a user creates a session, NetworkDiscoveryWithAnchors will call UNETAnchorManagers CreateAnchor function.</span></span> <span data-ttu-id="d1121-283">ここでは、CreateAnchor フローについて説明します。</span><span class="sxs-lookup"><span data-stu-id="d1121-283">Let's follow CreateAnchor flow.</span></span>

<span data-ttu-id="d1121-284">まずは、前のアンカー用に収集したデータを消去して、いくつかの作業を行います。</span><span class="sxs-lookup"><span data-stu-id="d1121-284">We start by doing some housekeeping, clearing out any data we may have collected for previous anchors.</span></span> <span data-ttu-id="d1121-285">次に、読み込むキャッシュされたアンカーがあるかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="d1121-285">Then we check if there is a cached anchor to load.</span></span> <span data-ttu-id="d1121-286">アンカーデータは 5 ~ 20 MB になる傾向があるため、キャッシュされたアンカーを再利用すると、ネットワーク経由で転送するために必要なデータ量を節約できます。</span><span class="sxs-lookup"><span data-stu-id="d1121-286">The anchor data tends to be between 5 and 20 MB, so reusing cached anchors can save on the amount of data we need to transfer over the network.</span></span> <span data-ttu-id="d1121-287">この方法については、後ほど説明します。</span><span class="sxs-lookup"><span data-stu-id="d1121-287">We'll see how this works a bit later.</span></span> <span data-ttu-id="d1121-288">アンカーを再利用する場合でも、アンカーを持たない新しいクライアント結合の場合に備えてアンカーデータを準備する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1121-288">Even if we are reusing the anchor, we need to get the anchor data ready in case a new client joins that doesn't have the anchor.</span></span>

<span data-ttu-id="d1121-289">アンカーデータを準備することにより、WorldAnchorTransferBatch クラスは、別のデバイスまたはアプリケーションに送信するためのアンカーデータを準備する機能、およびアンカーデータをインポートする機能を公開します。</span><span class="sxs-lookup"><span data-stu-id="d1121-289">Speaking of getting the anchor data ready, the WorldAnchorTransferBatch class exposes the functionality to prepare anchor data for sending to another device or application and the functionality to import the anchor data.</span></span> <span data-ttu-id="d1121-290">ここではエクスポートパスを利用しているため、アンカーを WorldAnchorTransferBatch に追加し、ExportAsync 関数を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="d1121-290">Since we're on the export path, we will add our anchor to the WorldAnchorTransferBatch and call the ExportAsync function.</span></span> <span data-ttu-id="d1121-291">ExportAsync は、エクスポートするデータを生成するときに、WriteBuffer コールバックを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="d1121-291">ExportAsync will then call the WriteBuffer callback as it generates data for export.</span></span> <span data-ttu-id="d1121-292">すべてのデータがエクスポートされると、ExportComplete が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-292">When all of the data has been exported ExportComplete will be called.</span></span> <span data-ttu-id="d1121-293">WriteBuffer では、エクスポートのために保持しているリストにデータのチャンクを追加します。</span><span class="sxs-lookup"><span data-stu-id="d1121-293">In WriteBuffer we add the chunk of data to a list we keep for exporting.</span></span> <span data-ttu-id="d1121-294">ExportComplete で、リストを配列に変換します。</span><span class="sxs-lookup"><span data-stu-id="d1121-294">In ExportComplete we convert the list to an array.</span></span> <span data-ttu-id="d1121-295">また、AnchorName 変数も設定されています。これにより、他のデバイスがアンカーを持っていない場合にその要求をトリガーします。</span><span class="sxs-lookup"><span data-stu-id="d1121-295">The AnchorName variable is also set, which will trigger other devices to request the anchor if they don't have it.</span></span>

<span data-ttu-id="d1121-296">場合によっては、アンカーがエクスポートされない場合や、再作成するデータが少ない場合があります。</span><span class="sxs-lookup"><span data-stu-id="d1121-296">In some cases the anchor won't export or will create so little data that we will try again.</span></span> <span data-ttu-id="d1121-297">ここでは、CreateAnchor をもう一度呼び出します。</span><span class="sxs-lookup"><span data-stu-id="d1121-297">Here we just call CreateAnchor again.</span></span>

<span data-ttu-id="d1121-298">エクスポートパスの最後の関数は AnchorFoundRemotely です。</span><span class="sxs-lookup"><span data-stu-id="d1121-298">A final function in the export path is AnchorFoundRemotely.</span></span> <span data-ttu-id="d1121-299">別のデバイスがアンカーを検出すると、そのデバイスはホストに通知します。ホストは、アンカーが "良好なアンカー" であり、キャッシュできることを示す信号としてそれを使用します。</span><span class="sxs-lookup"><span data-stu-id="d1121-299">When another device finds the anchor, that device will tell the host, and the host will use that as a signal that the anchor is a "good anchor" and can be cached.</span></span>

<span data-ttu-id="d1121-300">**込ん**</span><span class="sxs-lookup"><span data-stu-id="d1121-300">**Importing:**</span></span>

<span data-ttu-id="d1121-301">HoloLens がセッションに参加する場合は、アンカーをインポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1121-301">When a HoloLens joins a session, it needs to import an anchor.</span></span> <span data-ttu-id="d1121-302">UNETAnchorManager の Update 関数では、AnchorName がポーリングされます。</span><span class="sxs-lookup"><span data-stu-id="d1121-302">In UNETAnchorManager's Update function, the AnchorName is polled.</span></span> <span data-ttu-id="d1121-303">アンカー名が変更されると、インポートプロセスが開始されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-303">When the anchor name changes, the import process begins.</span></span> <span data-ttu-id="d1121-304">まず、指定された名前のアンカーをローカルアンカーストアから読み込みます。</span><span class="sxs-lookup"><span data-stu-id="d1121-304">First, we try to load the anchor with the specified name from the local anchor store.</span></span> <span data-ttu-id="d1121-305">既にお持ちの場合は、データを再度ダウンロードすることなく使用できます。</span><span class="sxs-lookup"><span data-stu-id="d1121-305">If we already have it, we can use it without downloading the data again.</span></span> <span data-ttu-id="d1121-306">そうでない場合は、WaitForAnchor を呼び出してダウンロードを開始します。</span><span class="sxs-lookup"><span data-stu-id="d1121-306">If we don't have it, then we call WaitForAnchor which will initiate the download.</span></span>

<span data-ttu-id="d1121-307">ダウンロードが完了すると、NetworkTransmitter_dataReadyEvent が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-307">When the download is completed, NetworkTransmitter_dataReadyEvent is called.</span></span> <span data-ttu-id="d1121-308">これにより、ダウンロードしたデータを使用して、更新ループによって、更新プログラムが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-308">This will signal the Update loop to call ImportAsync with the downloaded data.</span></span> <span data-ttu-id="d1121-309">インポート処理が完了すると、ImportComplete が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-309">ImportAsync will call ImportComplete when the import process is complete.</span></span> <span data-ttu-id="d1121-310">インポートが成功すると、アンカーはローカルのプレーヤーストアに保存されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-310">If the import is successful, the anchor will be saved in the local player store.</span></span> <span data-ttu-id="d1121-311">PlayerController.cs は、適切なアンカーが確立されたことをホストに知らせるために、実際には AnchorFoundRemotely の呼び出しを行います。</span><span class="sxs-lookup"><span data-stu-id="d1121-311">PlayerController.cs actually makes the call to AnchorFoundRemotely to let the host know that a good anchor has been established.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="d1121-312">進捗を楽しんでください</span><span class="sxs-lookup"><span data-stu-id="d1121-312">Enjoy your progress</span></span>

<span data-ttu-id="d1121-313">この時点で、HoloLens を使用するユーザーは、UI の [**セッションの開始**] ボタンを使用してセッションをホストします。</span><span class="sxs-lookup"><span data-stu-id="d1121-313">This time a user with a HoloLens will host a session using the **start session** button in the UI.</span></span> <span data-ttu-id="d1121-314">HoloLens またはイマーシブヘッドセットの両方で他のユーザーがセッションを選択し、UI の [**セッションに参加**] ボタンを選択します。</span><span class="sxs-lookup"><span data-stu-id="d1121-314">Other users, both on HoloLens or an immersive headset, will select the session and then select the **join session** button in the UI.</span></span> <span data-ttu-id="d1121-315">複数のユーザーが HoloLens デバイスを使用している場合は、そのヘッドに赤い雲があります。</span><span class="sxs-lookup"><span data-stu-id="d1121-315">If you have multiple people with HoloLens devices, they will have red clouds over their heads.</span></span> <span data-ttu-id="d1121-316">また、イマーシブヘッドセットごとに青いクラウドもありますが、ヘッドホンが HoloLens デバイスと同じワールド座標空間を見つけようとしていないため、青い雲はヘッドセットの上にありません。</span><span class="sxs-lookup"><span data-stu-id="d1121-316">There will also be a blue cloud for each immersive headset, but the blue clouds will not be above the headsets, as the headsets are not trying to find the same world coordinate space as the HoloLens devices.</span></span>

<span data-ttu-id="d1121-317">プロジェクト内のこのポイントは、含まれている共有アプリケーションです。それほど多くはありません。ベースラインとして機能する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d1121-317">This point in the project is a contained sharing application; it doesn't do very much, and could act as a baseline.</span></span> <span data-ttu-id="d1121-318">次の章では、お客様にご利用いただけるエクスペリエンスの構築を開始します。</span><span class="sxs-lookup"><span data-stu-id="d1121-318">In the next chapters, we will start building an experience for people to enjoy.</span></span> <span data-ttu-id="d1121-319">共有エクスペリエンスの設計に関する詳細なガイダンスについては、こちらを参照してください。</span><span class="sxs-lookup"><span data-stu-id="d1121-319">To get further guidance on shared experience design, go here.</span></span>

## <a name="chapter-4---immersion-and-teleporting"></a><span data-ttu-id="d1121-320">第4章-Immersion と受付移植</span><span class="sxs-lookup"><span data-stu-id="d1121-320">Chapter 4 - Immersion and teleporting</span></span>

>[!VIDEO https://www.youtube.com/embed/kUHZ5tCOfvY]

### <a name="objectives"></a><span data-ttu-id="d1121-321">目的</span><span class="sxs-lookup"><span data-stu-id="d1121-321">Objectives</span></span>

<span data-ttu-id="d1121-322">さまざまな種類の mixed reality デバイスにエクスペリエンスを提供します。</span><span class="sxs-lookup"><span data-stu-id="d1121-322">Cater the experience to each type of mixed reality device.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="d1121-323">ビルドする内容</span><span class="sxs-lookup"><span data-stu-id="d1121-323">What we will build</span></span>

<span data-ttu-id="d1121-324">アプリケーションを更新して、イマーシブビューを使用して、イマーシブヘッドセットユーザーを島に配置します。</span><span class="sxs-lookup"><span data-stu-id="d1121-324">We will update the application to put immersive headset users on the island with an immersive view.</span></span> <span data-ttu-id="d1121-325">HoloLens ユーザーには、島の概観が表示されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-325">HoloLens users will still have the bird's eye view of the island.</span></span> <span data-ttu-id="d1121-326">各デバイスの種類のユーザーは、世界中に表示されている他のユーザーを見ることができます。</span><span class="sxs-lookup"><span data-stu-id="d1121-326">Users of each device type can see other users as they appear in the world.</span></span> <span data-ttu-id="d1121-327">たとえば、イマーシブヘッドセットユーザーは、島の他のパスで他のアバターを見ることができ、その島の上にジャイアントクラウドとして HoloLens ユーザーが表示されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-327">For instance, immersive headset users can see the other avatars on other paths on the island, and they see the HoloLens users as giant clouds above the island.</span></span> <span data-ttu-id="d1121-328">イマーシブヘッドセットユーザーは、HoloLens ユーザーが島を見ている場合に、HoloLens ユーザーの宝石のカーソルも表示されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-328">Immersive headset users will also see the cursor of the HoloLens user's gaze ray if the HoloLens user is looking at the island.</span></span> <span data-ttu-id="d1121-329">HoloLens ユーザーには、各イマーシブヘッドセットユーザーを表すアバターが島上に表示されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-329">HoloLens users will see an avatar on the island to represent each immersive headset user.</span></span>

<span data-ttu-id="d1121-330">**イマーシブデバイスの入力が更新されました:**</span><span class="sxs-lookup"><span data-stu-id="d1121-330">**Updated Input for the Immersive device:**</span></span>
* <span data-ttu-id="d1121-331">Xbox コントローラーの左バンパーボタンと右バンパーボタンは、プレーヤーを回転させます。</span><span class="sxs-lookup"><span data-stu-id="d1121-331">The left bumper and right bumper buttons on the Xbox controller rotate the player</span></span>
* <span data-ttu-id="d1121-332">Xbox コントローラーの Y ボタンを押すと、[テレポート](navigating-the-windows-mixed-reality-home.md#getting-around-your-home)カーソルが有効になります。</span><span class="sxs-lookup"><span data-stu-id="d1121-332">Holding the Y button on the Xbox controller will enable a [teleport](navigating-the-windows-mixed-reality-home.md#getting-around-your-home) cursor.</span></span> <span data-ttu-id="d1121-333">Y ボタンを離したときにカーソルの矢印インジケーターが回転している場合は、カーソルの位置に移動します。</span><span class="sxs-lookup"><span data-stu-id="d1121-333">If the cursor has a spinning arrow indicator when you release the Y button, you will be teleported to the cursor's location.</span></span>

### <a name="steps"></a><span data-ttu-id="d1121-334">手順</span><span class="sxs-lookup"><span data-stu-id="d1121-334">Steps</span></span>
* <span data-ttu-id="d1121-335">MixedRealityTeleport を MixedRealityCameraParent に追加する</span><span class="sxs-lookup"><span data-stu-id="d1121-335">Add MixedRealityTeleport to MixedRealityCameraParent</span></span>
    * <span data-ttu-id="d1121-336">[**階層**] で [ **usland**] を選択します。</span><span class="sxs-lookup"><span data-stu-id="d1121-336">In **Hierarchy**, select **Usland**.</span></span>
    * <span data-ttu-id="d1121-337">**インスペクター**で、**レベルの制御**を有効にします。</span><span class="sxs-lookup"><span data-stu-id="d1121-337">In **Inspector**, enable **Level Control**.</span></span>
    * <span data-ttu-id="d1121-338">[**階層**] で [ **MixedRealityCameraParent**] を選択します。</span><span class="sxs-lookup"><span data-stu-id="d1121-338">In **Hierarchy**, select **MixedRealityCameraParent**.</span></span>
    * <span data-ttu-id="d1121-339">[**インスペクター**] で、[**コンポーネントの追加**] をクリックします。</span><span class="sxs-lookup"><span data-stu-id="d1121-339">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="d1121-340">「 **Mixed Reality テレポート**」と入力して選択します。</span><span class="sxs-lookup"><span data-stu-id="d1121-340">Type **Mixed Reality Teleport** and select it.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="d1121-341">コードの調査</span><span class="sxs-lookup"><span data-stu-id="d1121-341">Digging into the code</span></span>

<span data-ttu-id="d1121-342">イマーシブヘッドセットユーザーはケーブルを使用して Pc にテザリングさされますが、この島はケーブルの長さが長いことを示しています。</span><span class="sxs-lookup"><span data-stu-id="d1121-342">Immersive headset users will be tethered to their PCs with a cable, but our island is larger than the cable is long.</span></span> <span data-ttu-id="d1121-343">補正するには、ユーザーの動きとは無関係にカメラを移動する機能が必要です。</span><span class="sxs-lookup"><span data-stu-id="d1121-343">To compensate, we need the ability to move the camera independently of the user's motion.</span></span> <span data-ttu-id="d1121-344">Mixed reality アプリケーション (特に自己動きと locomotion) の設計の詳細については、[快適なページ](comfort.md)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d1121-344">Please see the [comfort page](comfort.md) for more information about designing your mixed reality application (in particular self motion and locomotion).</span></span>

<span data-ttu-id="d1121-345">このプロセスを説明するために、2つの用語を定義すると便利です。</span><span class="sxs-lookup"><span data-stu-id="d1121-345">In order to describe this process it will be useful to define two terms.</span></span> <span data-ttu-id="d1121-346">まず、 **dolly**は、ユーザーとは別にカメラを移動するオブジェクトになります。</span><span class="sxs-lookup"><span data-stu-id="d1121-346">First, **dolly** will be the object that moves the camera independently from the user.</span></span> <span data-ttu-id="d1121-347">**Dolly**の子ゲームオブジェクトが**メインカメラ**になります。</span><span class="sxs-lookup"><span data-stu-id="d1121-347">A child game object of the **dolly** will be the **main camera**.</span></span> <span data-ttu-id="d1121-348">メインカメラは、ユーザーの先頭に接続されています。</span><span class="sxs-lookup"><span data-stu-id="d1121-348">The main camera is attached to the user's head.</span></span>

<span data-ttu-id="d1121-349">[プロジェクト] パネルで、 **Assets\AppPrefabs\Support\Scripts\GameLogic**に移動し、 **MixedRealityTeleport.cs**をダブルクリックします。</span><span class="sxs-lookup"><span data-stu-id="d1121-349">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **MixedRealityTeleport.cs**.</span></span>

<span data-ttu-id="d1121-350">MixedRealityTeleport には2つのジョブがあります。</span><span class="sxs-lookup"><span data-stu-id="d1121-350">MixedRealityTeleport has two jobs.</span></span> <span data-ttu-id="d1121-351">まず、バンパーを使用して回転を処理します。</span><span class="sxs-lookup"><span data-stu-id="d1121-351">First, it handles rotation using the bumpers.</span></span> <span data-ttu-id="d1121-352">Update 関数では、左バンパーと右バンパーの "ButtonUp" をポーリングします。</span><span class="sxs-lookup"><span data-stu-id="d1121-352">In the update function we poll for 'ButtonUp' on LeftBumper and RightBumper.</span></span> <span data-ttu-id="d1121-353">GetButtonUp は、最初のフレームに対してのみ true を返します。ボタンはダウンした後に起動します。</span><span class="sxs-lookup"><span data-stu-id="d1121-353">GetButtonUp only returns true on the first frame a button is up after having been down.</span></span> <span data-ttu-id="d1121-354">いずれかのボタンが発生した場合は、ユーザーを回転させる必要があることがわかります。</span><span class="sxs-lookup"><span data-stu-id="d1121-354">If either button had been raised, then we know the user needs to rotate.</span></span>

<span data-ttu-id="d1121-355">回転を行うときは、"フェードコントロール" と呼ばれる単純なスクリプトを使用してフェードアウトし、フェードインします。</span><span class="sxs-lookup"><span data-stu-id="d1121-355">When we rotate we do a fade out and fade in using a simple script called 'fade control'.</span></span> <span data-ttu-id="d1121-356">これは、不快感につながる可能性がある不自然な動きをユーザーが見られないようにするためです。</span><span class="sxs-lookup"><span data-stu-id="d1121-356">We do this to prevent the user from seeing an unnatural movement which could lead to discomfort.</span></span> <span data-ttu-id="d1121-357">フェードインとフェード効果は非常に単純です。</span><span class="sxs-lookup"><span data-stu-id="d1121-357">The fade in and out effect is fairly simple.</span></span> <span data-ttu-id="d1121-358">**メインカメラ**の前面に黒いクワッドがハングしています。</span><span class="sxs-lookup"><span data-stu-id="d1121-358">We have a black quad hanging in front of the **main camera**.</span></span> <span data-ttu-id="d1121-359">フェードアウトすると、アルファ値は0から1に移行されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-359">When fading out we transition the alpha value from 0 to 1.</span></span> <span data-ttu-id="d1121-360">これにより、クワッドの黒いピクセルが徐々にレンダリングされ、その背後に隠れる部分が見えなくなります。</span><span class="sxs-lookup"><span data-stu-id="d1121-360">This gradually causes the black pixels of the quad to render and obscure anything behind them.</span></span> <span data-ttu-id="d1121-361">フェードバック時に、アルファ値を0に戻します。</span><span class="sxs-lookup"><span data-stu-id="d1121-361">When fading back in we transition the alpha value back to zero.</span></span>

<span data-ttu-id="d1121-362">回転を計算するときは、 **dolly**を回転させながら、**メインカメラ**の回転を計算することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="d1121-362">When we calculate the rotation, note that we are rotating our **dolly** but calculating the rotation around the **main camera**.</span></span> <span data-ttu-id="d1121-363">これは、**メインカメラ**が0、0、0から離れているほど正確ではありません。これは、dolly の周りの回転がユーザーの観点から見た場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="d1121-363">This is important as the farther the **main camera** is away from 0,0,0, the less accurate a rotation around the dolly would become from the point of view of the user.</span></span> <span data-ttu-id="d1121-364">実際、カメラの位置を中心に回転しない場合、ユーザーは回転ではなく、 **dolly**の周りの弧を移動します。</span><span class="sxs-lookup"><span data-stu-id="d1121-364">In fact, if you do not rotate around the camera position, the user will move on an arc around the **dolly** rather than rotating.</span></span>

<span data-ttu-id="d1121-365">MixedRealityTeleport の2番目のジョブは、 **dolly**の移動を処理します。</span><span class="sxs-lookup"><span data-stu-id="d1121-365">The second job for MixedRealityTeleport is to handle moving the **dolly**.</span></span> <span data-ttu-id="d1121-366">これは SetWorldPosition で行われます。</span><span class="sxs-lookup"><span data-stu-id="d1121-366">This is done in SetWorldPosition.</span></span> <span data-ttu-id="d1121-367">SetWorldPosition は、目的の世界の位置、つまりユーザーがモックした位置を取得します。</span><span class="sxs-lookup"><span data-stu-id="d1121-367">SetWorldPosition takes the desired world position, the position where the user wants to percieve that they inhabit.</span></span> <span data-ttu-id="d1121-368">このオフセットはフレームごとに追加されるので、その位置から**メインカメラ**のローカル位置を引いた位置に**dolly**を配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1121-368">We need to put our **dolly** at that position minus the local position of the **main camera**, as that offset will be added each frame.</span></span>

<span data-ttu-id="d1121-369">2番目のスクリプトは SetWorldPosition を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="d1121-369">A second script calls SetWorldPosition.</span></span> <span data-ttu-id="d1121-370">そのスクリプトを見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="d1121-370">Let's look at that script.</span></span> <span data-ttu-id="d1121-371">[プロジェクト] パネルで、 **Assets\AppPrefabs\Support\Scripts\GameLogic**に移動し、 **TeleportScript.cs**をダブルクリックします。</span><span class="sxs-lookup"><span data-stu-id="d1121-371">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **TeleportScript.cs**.</span></span>

<span data-ttu-id="d1121-372">このスクリプトは、MixedRealityTeleport よりも少し複雑です。</span><span class="sxs-lookup"><span data-stu-id="d1121-372">This script is a little more involved than MixedRealityTeleport.</span></span> <span data-ttu-id="d1121-373">このスクリプトでは、停止する Xbox コントローラーの Y ボタンがあるかどうかを確認しています。</span><span class="sxs-lookup"><span data-stu-id="d1121-373">The script is checking for the Y Button on the Xbox controller to be held down.</span></span> <span data-ttu-id="d1121-374">このボタンが押されている間、テレポートカーソルが表示され、スクリプトはユーザーの見つめ位置から射線をキャストします。</span><span class="sxs-lookup"><span data-stu-id="d1121-374">While the button is held down a teleport cursor is rendered and the script casts a ray from the user's gaze position.</span></span> <span data-ttu-id="d1121-375">その光線が、上向きまたは小さいサーフェイスと競合している場合、その表面は、テレポートするのに適切なサーフェイスと見なされ、テレポートカーソルのアニメーションが有効になります。</span><span class="sxs-lookup"><span data-stu-id="d1121-375">If that ray collides with a surface that is more or less pointing up, the surface will be considered a good surface to teleport to, and the animation on the teleport cursor will be enabled.</span></span> <span data-ttu-id="d1121-376">射線が上向きまたは低いサーフェイスと競合しない場合、カーソルのアニメーションは無効になります。</span><span class="sxs-lookup"><span data-stu-id="d1121-376">If the ray does not collide with a surface more or less pointing up, then the animation on the cursor will be disabled.</span></span> <span data-ttu-id="d1121-377">Y ボタンが離され、射線の計算されたポイントが有効な位置である場合、このスクリプトは、射線が交差する位置を使用して SetWorldPosition を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="d1121-377">When the Y button is released and the calculated point of the ray is a valid position, the script calls SetWorldPosition with the position the ray intersected.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="d1121-378">進捗を楽しんでください</span><span class="sxs-lookup"><span data-stu-id="d1121-378">Enjoy your progress</span></span>

<span data-ttu-id="d1121-379">今回は、友人を見つける必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1121-379">This time you'll need to find a friend.</span></span>

<span data-ttu-id="d1121-380">この場合も、HoloLens を使用するユーザーはセッションをホストします。</span><span class="sxs-lookup"><span data-stu-id="d1121-380">Once again, a user with the HoloLens will host a session.</span></span> <span data-ttu-id="d1121-381">他のユーザーがセッションに参加します。</span><span class="sxs-lookup"><span data-stu-id="d1121-381">Other users will join the session.</span></span> <span data-ttu-id="d1121-382">このアプリケーションでは、最初の3人のユーザーを、島の3つのパスのいずれかにあるイマーシブヘッドセットから結合するように配置します。</span><span class="sxs-lookup"><span data-stu-id="d1121-382">The application will place the first three users to join from an immersive headset on one of the three paths on the island.</span></span> <span data-ttu-id="d1121-383">このセクションでは、島を自由に調べることができます。</span><span class="sxs-lookup"><span data-stu-id="d1121-383">Feel free to explore the island in this section.</span></span>

<span data-ttu-id="d1121-384">注意事項:</span><span class="sxs-lookup"><span data-stu-id="d1121-384">Details to notice:</span></span>
1. <span data-ttu-id="d1121-385">クラウド内の顔を見ることができます。これにより、専念ユーザーは、HoloLens ユーザーが見ている方向を見ることができます。</span><span class="sxs-lookup"><span data-stu-id="d1121-385">You can see faces in the clouds, which helps an immersed user see which direction a HoloLens user is looking.</span></span>
2. <span data-ttu-id="d1121-386">島のアバターには、回転する necks があります。</span><span class="sxs-lookup"><span data-stu-id="d1121-386">The avatars on the island have necks that rotate.</span></span> <span data-ttu-id="d1121-387">ユーザーが行っていることは、実際にはありませんが (この情報はありません)、快適なエクスペリエンスを実現します。</span><span class="sxs-lookup"><span data-stu-id="d1121-387">They won't follow what the user is doing is real reality (we don't have that information) but it makes for a nice experience.</span></span>
3. <span data-ttu-id="d1121-388">HoloLens ユーザーが島を見ている場合、専念ユーザーはカーソルを見ることができます。</span><span class="sxs-lookup"><span data-stu-id="d1121-388">If the HoloLens user is looking at the Island, the immersed users can see their cursor.</span></span>
4. <span data-ttu-id="d1121-389">ユーザーがシャドウをキャストする HoloLens を表すクラウド。</span><span class="sxs-lookup"><span data-stu-id="d1121-389">The clouds that represent the HoloLens users cast shadows.</span></span>

## <a name="chapter-5---finale"></a><span data-ttu-id="d1121-390">章 5-くくり</span><span class="sxs-lookup"><span data-stu-id="d1121-390">Chapter 5 - Finale</span></span>

>[!VIDEO https://www.youtube.com/embed/n_HDWJbfpNg]

### <a name="objectives"></a><span data-ttu-id="d1121-391">目的</span><span class="sxs-lookup"><span data-stu-id="d1121-391">Objectives</span></span>

<span data-ttu-id="d1121-392">2つのデバイスの種類の間にコラボレーションによる対話型エクスペリエンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="d1121-392">Create a collaborative interactive experience between the two device types.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="d1121-393">ビルドする内容</span><span class="sxs-lookup"><span data-stu-id="d1121-393">What we will build</span></span>

<span data-ttu-id="d1121-394">第4章では、イマーシブヘッドセットを使用しているユーザーが島のパズルの近くにいる場合、HoloLens ユーザーには、パズルの手掛かりとなるツールヒントが表示されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-394">Building on chapter 4, when a user with an immersive headset gets near a puzzle on the island, the HoloLens users will get a tool tip with a clue to the puzzle.</span></span> <span data-ttu-id="d1121-395">すべてのイマーシブヘッドセットユーザーがパズルを越えて、ロケット部屋の "ready pad" に戻ると、ロケットが起動します。</span><span class="sxs-lookup"><span data-stu-id="d1121-395">Once all of the immersive headset users get past their puzzles and onto the "ready pad" in the rocket room, the rocket will launch.</span></span>

### <a name="steps"></a><span data-ttu-id="d1121-396">手順</span><span class="sxs-lookup"><span data-stu-id="d1121-396">Steps</span></span>
* <span data-ttu-id="d1121-397">[**階層**] で [ **usland**] を選択します。</span><span class="sxs-lookup"><span data-stu-id="d1121-397">In **Hierarchy**, select **Usland**.</span></span>
* <span data-ttu-id="d1121-398">**インスペクター**の**レベルコントロール**で、[**コラボレーションを有効にする**] チェックボックスをオンにします。</span><span class="sxs-lookup"><span data-stu-id="d1121-398">In **Inspector**, in **Level Control**, check **Enable Collaboration**.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="d1121-399">コードの調査</span><span class="sxs-lookup"><span data-stu-id="d1121-399">Digging into the code</span></span>

<span data-ttu-id="d1121-400">では、LevelControl.cs を見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="d1121-400">Now let us look at LevelControl.cs.</span></span> <span data-ttu-id="d1121-401">このスクリプトはゲームロジックの中核であり、ゲームの状態を維持します。</span><span class="sxs-lookup"><span data-stu-id="d1121-401">This script is the core of the game logic and maintains the game state.</span></span> <span data-ttu-id="d1121-402">これは UNET を使用するマルチプレイヤーゲームであるため、少なくともこのチュートリアルを変更するのに十分なデータフローを理解する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1121-402">Since this is a multiplayer game using UNET we need to understand how data flows, at least well enough to modify this tutorial.</span></span> <span data-ttu-id="d1121-403">UNET の概要については、Unity のドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="d1121-403">For a more complete overview of UNET, please refer to Unity's documentation.</span></span>

<span data-ttu-id="d1121-404">[プロジェクト] パネルで、 **Assets\AppPrefabs\Support\Scripts\GameLogic**に移動し、 **LevelControl.cs**をダブルクリックします。</span><span class="sxs-lookup"><span data-stu-id="d1121-404">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **LevelControl.cs**.</span></span>

<span data-ttu-id="d1121-405">イマーシブヘッドセットがロケット起動の準備ができていることを示す方法を説明します。</span><span class="sxs-lookup"><span data-stu-id="d1121-405">Let us understand how an immersive headset indicates that they are ready for the rocket launch.</span></span> <span data-ttu-id="d1121-406">ロケット起動の準備状態は、3つのブールのいずれかを島の3つのパスに対応するブールの一覧に設定することによって伝達されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-406">Rocket Launch readiness is communicated by setting one of three bools in a list of bools that correspond to the three paths on the island.</span></span> <span data-ttu-id="d1121-407">パスに割り当てられたユーザーが、ロケット部屋内の茶色のパッドの上にあるときに、パスの bool が設定されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-407">A path's bool will be set when the user assigned to the path is on top of the brown pad inside the rocket room.</span></span> <span data-ttu-id="d1121-408">では、詳細について説明します。</span><span class="sxs-lookup"><span data-stu-id="d1121-408">Okay, now to the details.</span></span>

<span data-ttu-id="d1121-409">Update () 関数で開始します。</span><span class="sxs-lookup"><span data-stu-id="d1121-409">We will start in the Update() function.</span></span> <span data-ttu-id="d1121-410">"カンニング" 関数があることを確認します。</span><span class="sxs-lookup"><span data-stu-id="d1121-410">You will note that there is a 'cheat' function.</span></span> <span data-ttu-id="d1121-411">これを開発で使用して、ロケットの起動とリセットのシーケンスをテストしています。</span><span class="sxs-lookup"><span data-stu-id="d1121-411">We used this in development to test the rocket launch and reset sequence.</span></span> <span data-ttu-id="d1121-412">複数のユーザーエクスペリエンスでは機能しません。</span><span class="sxs-lookup"><span data-stu-id="d1121-412">It won't work in the multi user experience.</span></span> <span data-ttu-id="d1121-413">次のような情報を内在化たときに、うまくいくことができます。</span><span class="sxs-lookup"><span data-stu-id="d1121-413">Hopefully by the time you internalize the following infromation you can make it work.</span></span> <span data-ttu-id="d1121-414">どうしたらよいかを確認したら、ローカルプレーヤーが専念かどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="d1121-414">After we check to see if we should cheat, we check to see if the local player is immersed.</span></span> <span data-ttu-id="d1121-415">私たちは、目標を達成していることを確認したいと考えています。</span><span class="sxs-lookup"><span data-stu-id="d1121-415">We want to focus on how we find that we're at the goal.</span></span> <span data-ttu-id="d1121-416">If (専念) チェックの内部では、 **EnableCollaboration** bool の背後にある checkgoal が非表示になっています。</span><span class="sxs-lookup"><span data-stu-id="d1121-416">Inside of the if (Immersed) check, there is a call to CheckGoal hiding behind the **EnableCollaboration** bool.</span></span> <span data-ttu-id="d1121-417">これは、この章の手順を完了している間にチェックしたチェックボックスに対応しています。</span><span class="sxs-lookup"><span data-stu-id="d1121-417">This corresponds to the checkbox you checked while completing the steps for this chapter.</span></span> <span data-ttu-id="d1121-418">EnableCollaboration の中に、CheckGoal () の呼び出しが表示されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-418">Inside of EnableCollaboration we see a call to CheckGoal().</span></span>

<span data-ttu-id="d1121-419">CheckGoal では、パッドの表示が大きくなっているか少ないかを調べることができます。</span><span class="sxs-lookup"><span data-stu-id="d1121-419">CheckGoal does some math to see if we are more or less standing on the pad.</span></span> <span data-ttu-id="d1121-420">このような場合は、"目標に到達しました" というログを記録し、"Sendatゴール Message ()" というメッセージを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="d1121-420">When we are, we Debug.Log "Arrived at goal" and then we call 'SendAtGoalMessage()'.</span></span> <span data-ttu-id="d1121-421">Sendatゴール Message で、playerController を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="d1121-421">In SendAtGoalMessage we call playerController.SendAtGoal.</span></span> <span data-ttu-id="d1121-422">時間を節約するために、次のコードを使用します。</span><span class="sxs-lookup"><span data-stu-id="d1121-422">To save you some time, here's the code:</span></span>

```cs
private void CmdSendAtGoal(int GoalIndex)
       {
           levelState.SetGoalIndex(GoalIndex);
       }
```

```cs
public void SendAtGoal(int GoalIndex)
       {
           if (isLocalPlayer)
           {
               Debug.Log("sending at goal " + GoalIndex);
               CmdSendAtGoal(GoalIndex);
           }
       }
```

<span data-ttu-id="d1121-423">Sendatゴールメッセージは CmdSendAtGoal を呼び出します。これは LevelControl.cs に戻された levelState. Setゴール Index を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="d1121-423">Note that SendAtGoalMessage calls CmdSendAtGoal, which calls levelState.SetGoalIndex, which is back in LevelControl.cs.</span></span> <span data-ttu-id="d1121-424">一見すると、これは奇妙なように見えます。</span><span class="sxs-lookup"><span data-stu-id="d1121-424">At first glance this seems strange.</span></span> <span data-ttu-id="d1121-425">ここでは、プレーヤーコントローラーを介したこの奇妙なルーティングではなく、SetGoalIndex を呼び出すことができないのはなぜですか。</span><span class="sxs-lookup"><span data-stu-id="d1121-425">Why not just call SetGoalIndex rather than this strange routing through the player controller?</span></span> <span data-ttu-id="d1121-426">これは、データの同期を維持するために UNET が使用するデータモデルに準拠しているためです。不正行為とスラッシングを防ぐため、UNET では、同期された変数を変更する権限を持つユーザーを各オブジェクトが持っている必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1121-426">The reason is that we are conforming to the data model UNET uses to keep data in sync. To prevent cheating and thrashing, UNET requires that each object has a user who has authority to change the synchronized variables.</span></span> <span data-ttu-id="d1121-427">さらに、ホスト (セッションを開始したユーザー) のみがデータを直接変更できます。</span><span class="sxs-lookup"><span data-stu-id="d1121-427">Further, only the host (the user that started the session) can change data directly.</span></span> <span data-ttu-id="d1121-428">ホストではないが権限を持っているユーザーは、ホストに "コマンド" を送信して変数を変更する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1121-428">Users who are not the host, but have authority, need to send a 'command' to the host which will change the variable.</span></span> <span data-ttu-id="d1121-429">既定では、ホストには、ユーザーを表すために生成されたオブジェクトを除き、すべてのオブジェクトに対する権限があります。</span><span class="sxs-lookup"><span data-stu-id="d1121-429">By default the host has authority over all objects, except for the object spawned to represent the user.</span></span> <span data-ttu-id="d1121-430">この例では、このオブジェクトには playercontroller スクリプトが含まれています。</span><span class="sxs-lookup"><span data-stu-id="d1121-430">In our case this object has the playercontroller script.</span></span> <span data-ttu-id="d1121-431">オブジェクトの権限を要求してから変更を加える方法はありますが、プレーヤーコントローラーが自己権限を持ち、プレーヤーコントローラーを介してコマンドをルーティングするという事実を活用することを選択します。</span><span class="sxs-lookup"><span data-stu-id="d1121-431">There is a way to request authority for an object and then make changes, but we choose to leverage the fact that the player controller has self authority and route commands through the player controller.</span></span>

<span data-ttu-id="d1121-432">もう1つの方法として、この目標を達成した場合、プレーヤーはホストに指示する必要があり、ホストは他のユーザーに通知する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1121-432">Said another way, when we've found ourselves at our goal, the player needs to tell the host, and the host will tell everyone else.</span></span>

<span data-ttu-id="d1121-433">LevelControl.cs を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d1121-433">Back in LevelControl.cs look at SetGoalIndex.</span></span> <span data-ttu-id="d1121-434">ここでは、synclist (AtGoal) で値の値を設定しています。</span><span class="sxs-lookup"><span data-stu-id="d1121-434">Here we are setting the value of a value in a synclist (AtGoal).</span></span> <span data-ttu-id="d1121-435">これはホストのコンテキストであることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="d1121-435">Remember that we are in the context of the host while we do this.</span></span> <span data-ttu-id="d1121-436">コマンドと同様に、RPC とは、すべてのクライアントがいくつかのコードを実行するためにホストが発行できるものです。</span><span class="sxs-lookup"><span data-stu-id="d1121-436">Similar to a command, an RPC is something the host can issue that will cause all clients to run some code.</span></span> <span data-ttu-id="d1121-437">ここでは、' RpcCheckAllGoals ' を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="d1121-437">Here we call 'RpcCheckAllGoals'.</span></span> <span data-ttu-id="d1121-438">各クライアントは、3つの AtGoals がすべて設定されているかどうかを個別に確認し、存在する場合はロケットを起動します。</span><span class="sxs-lookup"><span data-stu-id="d1121-438">Each client will individually check to see if all three AtGoals are set, and if so, launch the rocket.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="d1121-439">進捗を楽しんでください</span><span class="sxs-lookup"><span data-stu-id="d1121-439">Enjoy your progress</span></span>

<span data-ttu-id="d1121-440">前の章では、前と同じようにセッションを開始します。</span><span class="sxs-lookup"><span data-stu-id="d1121-440">Building on the previous chapter, we will start the session as before.</span></span> <span data-ttu-id="d1121-441">今回は、イマーシブヘッドセットのユーザーがパスの "ドア" に到達すると、HoloLens ユーザーのみが表示できるツールヒントが表示されます。</span><span class="sxs-lookup"><span data-stu-id="d1121-441">This time as the users in the immersive headset get to the "door" on their path, a tooltip will appear that only the HoloLens users can see.</span></span> <span data-ttu-id="d1121-442">HoloLens ユーザーは、この手掛かりをイマーシブヘッドセット内のユーザーに伝える役割を担います。</span><span class="sxs-lookup"><span data-stu-id="d1121-442">The HoloLens users are responsible for communicating this clue to the users in the immersive headset.</span></span> <span data-ttu-id="d1121-443">各アバターが火山内の対応するブラウンパッドにステップインすると、ロケットがスペースで起動します。</span><span class="sxs-lookup"><span data-stu-id="d1121-443">The rocket will launch to space once each avatar has stepped on its corresponding brown pad inside the volcano.</span></span> <span data-ttu-id="d1121-444">シーンは60秒後にリセットされるので、再度行うことができます。</span><span class="sxs-lookup"><span data-stu-id="d1121-444">The scene will reset after 60 seconds so you can do it again.</span></span>

## <a name="see-also"></a><span data-ttu-id="d1121-445">関連項目</span><span class="sxs-lookup"><span data-stu-id="d1121-445">See also</span></span>
* [<span data-ttu-id="d1121-446">MR 入力 213:モーション コントローラー</span><span class="sxs-lookup"><span data-stu-id="d1121-446">MR Input 213: Motion controllers</span></span>](mixed-reality-213.md)
